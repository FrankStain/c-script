unit operators;
(**
 * Модуль операторов языка. Содержит классы, выполняющие роль определенных операторов,
 * для построения модели программы.
 *
 * Модель программы состоит из так называемого скрипта (script) и включенных в скрипт операторов.
 * При чем любой оператор так же может иметь подчиненный скрипт, что отображает иерархическую связь
 * между операторами (когда операторы могет группироваться в подблоки под управлением какого либо
 * иного оператора, как подблок относительно оператора if, или как тело функции относительно ее
 * заголовка).
 *
 * Модель отобразить можно так:
 *    Скрипт
 *     +- Оператор
 *     +  ...
 *     +- Оператор
 *     |   +- Скрипт
 *     +- Оператор
 *     +  ...
 *
 * Выполняясь, модель реализует непосредственную цель исходного кода - логические расчеты.
 * Выполнение модели - это последовательное, пошаговое выполнение каждого из ее операторов.
 * В том случае, если во время выполнения оператор не может логически закончить свою работу,
 * оператор генерирует состояние ошибки. Это состояние распространяется на скрипт, которому
 * пренадлежит оператор с ошибкой, и останавливает его работу.
 * В случае, если скрипт является подблоком какого либо оператора, состояние ошибки
 * распространяется и на сам оператор, подблоком которого является ошибочный скрипт, что приведет
 * к генерации ошибки самого оператора. И так далее.
 *
 * К состоянию ошибки одного оператора применимо правило математической индукции: в случае
 * возникновения ошибки в одном операторе, вне зависимости от степени вложенности оператора
 * относительно основного скрипта, весь процесс выполнения останавливается, а состояние
 * ошибки передается на самый верхний уровень.
 *
 * Общая иерархия классов модуля:
 *   TObject
 *    +- TBaseOperator
 *    |   +- TConstant
 *    |   |   +- TVariable
 *    |   |   +- TSTRConstant
 *    |   |   +- TFunction
 *    |   |   +- TSubScript
 *    |   |   +- TFunctionCall
 *    |   |   +- TOperation
 *    |   |   |   +- TOperationADD
 *    |   |   |   +- TOperationSUB
 *    |   |   |   +- TOperationMUL
 *    |   |   |   +- TOperationDIV
 *    |   |   |   +- TOperationMOD
 *    |   |   |   +- TOperationAND
 *    |   |   |   +- TOperationOR
 *    |   |   |   +- TOperationXOR
 *    |   |   |   +- TOperationABOVE
 *    |   |   |   +- TOperationBELOW
 *    |   |   |   +- TOperationEQUAL
 *    |   |   |   +- TOperationNOT
 *    |   |   |
 *    |   |   +- TExpressionIF
 *    |   |   +- TExpressionWHILE
 *    |   |   +- TExpressionDO
 *    |   |   +- TExpressionRET
 *    |   |   +- TExpressionECHO
 *    |   |
 *    |   x
 *    |
 *    +- TScript
 *    +- TVarList
 *    +- TVarListItem
 *
 *)

interface

uses
  Windows, Classes,
//--- Собственные модули ---------------------------------------------------------------------------
  TextMessages, tokenizer,
//--------------------------------------------------------------------------------------------------
  SysUtils;

Type
  (**
   * Перечисление допустимых типов данных
   *
   *)
  TVariableType = (
    vtUndef = 0,     // Неопределенный тип
    vtINT,           // Тип целого знакового числа
    vtFLOAT,         // Тип вещественного числа
    vtBOOL,          // Тип булевского значения (true / false)
    vtSTR            // Тип строкового значения
  );

  (**
   * Тип для хранения значения, для хранения значений разных типов используется механизм
   * объединения полей записи.
   *
   * В одно время может хранить только одно значение, но представить его может в любом
   * из трех базовых видов: int, float или bool
   * Представление значения производится без приведения типов.
   *
   * Размер записи составляет 4 байта.
   *
   *)
  TVariableValue = record
    case Byte of
      0: (iValue: integer);  // 4б. Для хранения данных в виде простого целого со знаком
      1: (fValue: single);   // 4б. Для хранения данных в виде вещественного числа
      2: (bValue: boolean);  // 1б. Для хранения данных в виде булевского значения.
  end;

  (**
   * Предопределение типов скрипта и константы, необходимо для перекрестной увязки типов.
   *
   *)
  TScript = class;
  TConstant = class;

  (**
   * Перечисление дополнительных опций оператора.
   * Служит для наделения конкретного оператора особыми свойствами.
   *
   *)
  TOperatorFlag = (
    ofNotActive,    // Метод Run оператора не будет выполнять свою логику
    ofNoReturn,     // Функция не останавливается по оператору return
    ofTraceOff,     // Скрипт не должен запускать метод Run у данного оператора
    ofMakeAssert,   // Реализовать assert при выполнении данного оператора (подсказка для дебага)
    ofBreakpoint    // Реализовать остановку скрипта и переход в режим пошаговой отладки на данном операторе
  );
  // Контейнер для содержания нескольких опций в одном операторе.
  TOperatorFlags = set of TOperatorFlag;

  (**
   * Класс базового оператора. Никакой логики, только служебный интерфейс и поля.
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *
   * Ссылочные связи классов:
   *   TBaseOperator
   *    +- TScript (1:1)
   *    +- TToken  (1:1)
   *
   *)
  TBaseOperator = class
    Protected
      (**
       * Ссылка на родительский скрипт, которому пренадлежит данный оператор.
       * При создании объекта оператора, он самостоятельно регистрируется в
       * родительском скрипте.
       *
       *)
      FScript: TScript;

      (**
       * Набор опций оператора.
       *
       *)
      FFlags: TOperatorFlags;

      (**
       * Ссылка на лексему, имя данного оператора.
       * При работе с исходным кодом необходимо не только знать строчку лексемы,
       * которой порожден данный оператор, но и ее место в исходном коде,
       * а так же тип лексемы.
       * Поэтому гораздо лучше будет сделать именно связь оператора с лексемой
       * из лексического анализатора.
       *
       *)
      FName: TToken;

      (**
       * Состояние ошибки оператора.
       *
       *)
      FError: TParserErrorState;

    Public
      (**
       * Конструктор оператора.
       * Создает сам оператор, определяет для него родительский скрипт и имя,
       * производит регистрацию данного оператора в родительском скрипте.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);

      (**
       * Деструктор оператора.
       * Удаляет подчиненные объекты и занятую в работе память, снимает регистрацию в
       * родительском скрипте.
       *
       *)
      Destructor Destroy; override;

      (**
       * Интерфейс запуска оператора.
       * Метод перегружается в дочерних классах для реализации логики конкретного операора.
       *
       *)
      Procedure Run; virtual;

      (**
       * Позволяет получить из оператора его строковое представление.
       *
       * Возвращает строку, символизирующую значение константы.
       *
       *)
      Function ToString: string; virtual;
      
      (**
       * Позволяет получить запись оператора в отладочном варианте.
       *
       * Возвращает строку, обоначающую значение константы в отладочном виде.
       *
       *)
      Function DBGString: string; virtual;

      (**
       * Свойство, позволяющее считать ссылку на родительский скрипт оператора.
       * Свойство только для читния.
       *
       *)
      Property Script: TScript read FScript;

      (**
       * Свойство для считывания состояния ошибки оператора.
       * Свойство только для чтения.
       *
       *)
      Property Error: TParserErrorState read FError;

      (**
       * Свойство для чтения имени оператора.
       * Свойство только для чтения.
       *
       *)
      Property Name: TToken read FName;

      (**
       * Свойство для доступа к флагам оператора.
       * Свойство для чтения и записи.
       *
       *)
      Property Flags: TOperatorFlags read FFlags write FFlags;
  end;

  (**
   * Предопределение элемента списка операторов
   *
   *)
  TVarListItem = class;

  (**
   * Класс списка переменных. Реализует методы для хранения в стиле FIFO необходимых
   * операторов скрипта.
   * Применяется для хранения ссылок уже зарегистрированных переменных и функций, по отдельности.
   *
   * Иерархия классов:
   *   TObject
   *    +- TVarList
   *
   * Ссылочные связи классов:
   *   TVarList
   *    +- TVarListItem (1:M)
   *
   *)
  TVarList = class
    Private
      (**
       * Хранилище ссылок.
       *
       *)
      FList: TList;

    Protected
      (**
       * Метод служит для регистрации элемента в хранилище.
       * Элемент сам вызывает этот метод в собственном конструкторе.
       *
       * Параметры:
       *   oVar - элемент списка, который необходимо зарегистрировать
       *
       *)
      Procedure AddVar(oVar: TVarListItem);

      (**
       * Метод снимает регистрацию элемента в хранилище.
       * Вызывается в деструкторе элемента списка.
       *
       * Параметры:
       *   oVar - элемент списка, который нужно снять с регистрации
       *
       *)
      Procedure RemVar(oVar: TVarListItem);

      (**
       * Возвращает элемент списка по его числовому индексу.
       *
       * Параметры:
       *   iIndex - индекс элемента в хранилище, самый первый элемент имеет индекс 0
       *
       * Возвращает ссылку на элемент списка или nil, если по данному индексу нет элемента
       *
       *)
      Function GetVar(iIndex: integer): TVarListItem;

      (**
       * Определяет количество элементов в хранилище.
       *
       * Возвращает целое число, количество элементов в хранилище
       *
       *)
      FUnction GetCount: integer;

    Public

      (**
       * Конструктор списка.
       *
       *)
      Constructor Create;

      (**
       * Деструктор списка.
       *
       *)
      Destructor Destroy; override;

      (**
       * Полная очистка списка.
       *
       *)
      Procedure Clear;

      (**
       * Регистрирует оператор скрипта в хранилище.
       *
       * Параметры:
       *   oVar - оператор скрипта. который нужно добавить в хранилище
       *
       *)
      Procedure Add(oVar: TConstant);

      (**
       * Удаляет оператор из хранилища
       *
       * Параметры:
       *   oVar - оператор скрипта, который необходимо удалить из хранилища
       *)
      Procedure Remove(oVar: TConstant);

      (**
       * Выполняет поиск оператора по его имени.
       *
       * Параметры:
       *   oName - лексема, по значению которой необходимо в хранилище найти оператор
       *
       * Возвращает элемент списка, в значении которого необходимый оператор, или nil,
       * если ничего не нашлось.
       *
       *)
      Function FindVar(oName: TToken): TVarListItem;

      (**
       * Свойство возвращает число элементов в хранилище на данный момент.
       * Только для чтения.
       *
       *)
      Property Count: integer read GetCount;

      (**
       * Войство для получения элемента списка по индексу.
       * Только для чтения. Является свойством по умолчанию.
       *
       *)
      Property List[iIndex: integer]: TVarListItem read GetVar; default;
  end;

  (**
   * Класс элемента списка операторов.
   * Самостоятельно регистрируется в хранилище списка операторов.
   * Самостоятельно снимается с регистрации.
   * Предоставляет интерфейс для хранения оператора в списке.
   *
   * Иерархия классов:
   *   TObject
   *    +- TVarListItem
   *
   * Ссылочные связи классов:
   *   TVarListItem
   *    +- TVarList  (1:1)
   *    +- TConstant (1:1)
   *
   *)
  TVarListItem = class
    Private

      (**
       * Ссылка на хозяина, список, в хранилище которого зарегистрирован элемент.
       *
       *)
      FParent: TVarList;

      (**
       * Ссылка на оператор, для которого заведен данный элемент списка.
       *
       *)
      FValue: TConstant;

    Public

      (**
       * Конструктор элемента списка.
       * Устанавливает хозяина И оператор для нового элемента.
       * Осуществляет регистрацию в хранилище хозяина.
       *
       * Параметры:
       *   oParent - ссылка на список, в котором будет содержаться данный элемент.
       *   oValue - оператор скрипта, для которого заводится данный элемент.
       *
       *)
      Constructor Create(oParent: TVarList; oValue: TConstant);

      (**
       * Деструктор элемента.
       * Снимает элемент с регистрации в хранилище хозяина.
       *
       *)
      Destructor Destroy; override;

      (**
       * Свойство позволяет считать ссылку на хозяина данного элемента.
       * Свойство только для чтения.
       *
       *)
      Property Parent: TVarList read FParent;

      (**
       * Свойство позволяет считать оператор скрипта из данного элемента.
       * Свойство только для чтения.
       *
       *)
      Property Value: TConstant read FValue;
  end;

  (**
   * Класс самого скрипта, основа модели исполняемого кода.
   *
   * Иерархия классов:
   *   TObject
   *    +- TScript
   *
   * Ссылочные связи классов:
   *   TScript
   *    +- TBaseOperator (1:M)
   *    +- TScript       (1:1)
   *    +- TVarList      (1:1)
   *    
   *)
  TScript = class
    Private

      (**
       * Ссылка на родительский скрипт. Считать можно так: если данное поле равно nil,
       * значит это есть основной скрипт программы.
       *
       *)
      FParent: TScript;

      (**
       * Хранилище операторов данного скрипта.
       *
       *)
      FOperators: TList;
      
      (**
       * Значение, возвращаемое скриптом. Используется не всегда.
       *
       *)
      FValue: TVariableValue;

      (**
       * Тип возвращаемого значения.
       *
       *)
      FValueType: TVariableType;

      (**
       * Флаг "Скрипт в работе", если этот флаг сбросить, скрипт остановится.
       *
       *)
      FWorkOn: boolean;

      (**
       * Хранилище инициализированных переменных.
       *
       *)
      FVariables: TVarList;

      (**
       * Хранилище объявленных функций
       *
       *)
      FFunctions: TVarList;

    Protected
      
      (**
       * Возвращает оператор из хранилища по его индексу
       *
       * Параметры:
       *   iIndex - относительный индекс оператора в хранилище, считается от 0
       *
       * Возвращает оператор по индексу или nil, если индекс неверен
       *
       *)
      Function GetOperator(iIndex: integer): TBaseOperator;
      
      (**
       * Возвращает количество операторов в скрипте.
       *
       *)
      Function GetCount: integer;

    Public
      
      (**
       * Конструктор скрипта.
       *
       * Параметры:
       *   oParent - родительский скрипт, можно и не указывать.
       *
       *)
      Constructor Create(oParent: TScript = nil);
      
      (**
       * Деструктор скрипта. Полностью очищает занимаимую скриптом и подчиненными объектами память.
       *
       *)
      Destructor Destroy; override;

      (**
       * Добавляет оператор в скрипт.
       *
       * Параметры:
       *   oOperator - оператор, который нужно добавить в скрипт.
       *
       *)
      Procedure Append(oOperator: TBaseOperator);
      
      (**
       * Убирает оператор из скрипта
       *
       * Параметры:
       *   oOperator - оператор, который нужно удалить из скрипта.
       *
       *)
      Procedure Remove(oOperator: TBaseOperator);
      
      (**
       * Убирает оператор из скрипта по его индексу
       *
       * Параметры:
       *   iIndex - индекс оператора для удаления.
       *
       *)
      Procedure Delete(iIndex: integer);

      (**
       * Удаляет все операторы из скрипта.
       *
       *)
      Procedure Clear;

      (**
       * По ссылке на оператор возвращает его порядковый индекс в хранилище
       *
       * Параметры:
       *   oOperator - оператор, для которого необходимо вернуть порядковый индекс.
       *
       *)
      Function IndexOf(oOperator: TBaseOperator): integer;

      (**
       * Метод выполнения скрипта.
       *
       *)
      Function Run: boolean;

      (**
       * Родительский скрипт.
       * Только для чтения.
       *
       *)
      Property Parent: TScript read FParent;

      (**
       * Позволяет получить ссылку на оператор по его порядковому индексу.
       * Только для чтения. Является свойством по умолчанию.
       *
       *)
      Property Operators[iIndex: integer]: TBaseOperator read GetOperator; default;

      (**
       * Количество операторов в хранилище.
       * Только для чтения.
       *
       *)
      Property Count: integer read GetCount;

      (**
       * Возвращаемое по окончании работы значение скрпта.
       * Обычно это результат оператора return для функции, в остальных
       * случаях свойство, как правило, обнулено.
       * Только для чтения.
       *
       *)
      Property RetValue: TVariableValue read FValue;

      (**
       * Тип возвращаемого значения.
       * Только для чтения.
       *
       *)
      Property RetType: TVariableType read FValueType;
  end;

  (**
   * Класс оператора типа "Константа". Помимо свойств базового оператора, класс наделен
   * всеми необходимыми свойствами константы, то есть значением и типом.
   *
   * Константа - это один из простейших операторов языка. Константу можно только объявить
   * с каким то определенным значением и далее это значение только читать.
   * Изменение значения константы во время выполнения скрипта недопустимо.
   * У константы точно так же есть оператор Run, этот оператор производит регистрацию
   * константы в общем списке констант и переменных скрипта.
   * Для инициализации константы, в классе описан метод Init, он должен быть вызван на стадии
   * сборки модели скрипта, когда будут определены тип и значение константы.
   *
   * В исходном коде этот оператор определен констукцией:
   *   const <Type> <Name> = <Value>;
   *
   *   const int iIntConstant = 256;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *
   * Ссылочные связи классов унаследованы от базового оператора.
   *
   *)
  TConstant = class(TBaseOperator)
    Protected

      (**
       * Значение данной константы
       *
       *)
      FValue: TVariableValue;

      (**
       * Тип значения
       *
       *)
      FValueType: TVariableType;

      (**
       * Позволяет установить значение FValue.
       * В данном классе этот метод является только заглушкой и лишь задает интерфейс
       * взаимодействия с полем FValue через свойство Value.
       *
       * Параметры:
       *   oValue - значение, которое необходимо записать в FValue
       *
       *)
      Procedure SetValue(oValue: TVariableValue); virtual;

      (**
       * Позволяет считать значение FValue
       *
       *)
      Function GetValue: TVariableValue; virtual;

    Public
      
      (**
       * Инициализация константы.
       *
       * Параметры:
       *   oValue - Значение, которое будет хранить константа
       *   eType  - Тип содержимого константы
       *
       *)
      Procedure Init(oValue: TVariableValue; eType: TVariableType);

      (**
       * Позволяет получить из оператора его строковое представление.
       *
       * Возвращает строку, символизирующую значение константы.
       *
       *)
      Function ToString: string; override;
      
      (**
       * Позволяет получить запись оператора в отладочном варианте.
       *
       * Возвращает строку, обоначающую значение константы в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Интерфейс запуска оператора.
       * Регистрирует константу в списке констант и переменных скрипта.
       *
       *)
      Procedure Run; override;

      (**
       * Возвращает тип значения константы.
       * Только для чтения.
       *
       *)
      Property Typecast: TVariableType read FValueType;

      (**
       * Возвращает значение константы.
       * Только для чтения.
       *
       *)
      Property Value: TVariableValue read GetValue write SetValue;
  end;

  (**
   * Класс оператора типа "Переменная", расширяет логику поведения константы.
   * Изменения заключаются лишь в том, что переменная позволяет изменять свое значение.
   * Тип так же задается только при инициализации и не может измениться во время выполнения скрпта.
   *
   * В исходном коде этот оператор определен констукцией (в квадратных скобках - необязательное):
   *   <Type> <Name>[ = <Value>];
   *
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TVariable
   *
   * Ссылочные связи классов унаследованы от базового оператора.
   *
   *)
  TVariable = class(TConstant)
    Protected
      
      (**
       * Позволяет установить значение FValue.
       * Реализует логику изменения значения переменной.
       *
       * Параметры:
       *   oValue - значение, которое необходимо записать в FValue
       *
       *)
      Procedure SetValue(oValue: TVariableValue); override;

  end;

  (**
   * Специальный класс строковой константы. Реализует логику хранения строк в скрипте.
   * В скрипте не допускается работа "напрямую" с константами или переменными типа "Строка",
   * строковые константы разрешается указывать только в операторе вывода (echo). Для такого
   * случая и разработан данный класс.
   *
   * Любя цифра или (в данном случае) строка - для скрипта это константа. Но такие константы не
   * должны регистрироваться при выполнении, это просто приведет к засорению соответствующего
   * спеиска скрипта. Если необходимо запретить выполняться какому либо оператору, необходимо
   * установить в его настройках значение ofNotActive.
   * Строковые константы уже создаются с этим флагом.
   *
   * Метод Init для данного класса принимает только строку, которой нужно инициализировать
   * константу, тип уже известен за рание - это тип строки (vtSTR)
   *
   * В исходном коде этот оператор определен констукцией:
   *   "<Value>"
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TSTRConstant
   *
   * Ссылочные связи классов унаследованы от базового оператора.
   *
   *)
  TSTRConstant = class(TConstant)
    Protected
      
      (**
       * Хранит знчение константы, теперь это уже строго строка.
       *
       *)
      FString: string;

      
      (**
       * Позволяет установить значение FString.
       * Метод так же ничего не выполняет, как и в классе TConstant, он лишь задает интерфейс
       * работы с полем FString через свойство Value.
       *
       * Параметры:
       *   sValue - Значение, которое необходимо записать в поле FString.
       *
       *)
      Procedure SetValue(sValue: string); virtual;
      
      (**
       * Возвращает значение поля FString.
       *
       *)
      Function GetValue: string; virtual;

    Public
      
      (**
       * Инициализация константы.
       *
       * Прараметры:
       *   sValue - значение, которым необходимо инициализировать константу.
       *
       *)
      Procedure Init(sValue: string);

      (**
       * Интерфейс запуска оператора.
       * Регистрирует константу в списке констант и переменных скрипта.
       *
       *)
      Procedure Run; override;
      
      (**
       * Позволяет получить из оператора его строковое представление.
       *
       * Возвращает строку, символизирующую значение константы.
       *
       *)
      Function ToString: string; override;

      (**
       * Позволяет получить запись оператора в отладочном варианте.
       *
       * Возвращает строку, обоначающую значение константы в отладочном виде.
       *
       *)
      Property Value: string read GetValue write SetValue;

  end;

  (**
   * Класс оператора типа "Функция". Функция является составным оператором, она позваляет выполнять
   * определенный блок операторов с передачей в него ряда параметров. Данный блок операторов
   * можно назвать подблоком или подпрограммой относительно основного скрипта, или просто
   * подскриптом. Фактически так и получается, функция имеет свой собственный объект-скрипт,
   * в котором и содержится набор тех самых операторов, а так же параметры функции в виде
   * переменных скрипта.
   *
   * Данный оператор выполняет роль декларации функции, его метод Run осуществляет регистрацию
   * функции в списке инициализированных функций основного скрипта, делая функцию доступной для
   * последующих вызовов. А метод Init - лишь устанавливает тип возвращаемого значения и
   * количество необходимых параметров функции.
   *
   * В исходном коде этот оператор определен констукцией (в квадратных скобках - необязательное):
   *   [const ]<Type> <FunctionName>( [<Type> <ParamName>[, <Type> <ParamName>]* ]* ){ <Operators> };
   *
   *   int MyFunction(){  };
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TFunction
   *
   * Ссылочные связи классов:
   *   TFunction
   *    +- TScript (1:1)
   *
   *)
  TFunction = class(TConstant)
    Protected
      
      (**
       * Подпрограмма, подскрипт тела функции.
       *
       *)
      FAction: TScript;
      
      (**
       * Число необходимых параметров, которые нужно передать функции перед ее вызовом.
       *
       *)
      FPrmCount: integer;

    Public
      
      (**
       * Конструктор функцци.
       * Помимо основных операций родительских классов, конструктор
       * создает тело функции - подскрипт.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор функции.
       * Необходим для очистки памяи тела функции.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Отладочная информация функции.
       *
       *)
      Function DBGString: string; override;
      
      (**
       * Интерфейс запуска оператора.
       * Регистрирует функцию в списке функций родительского скрипта.
       *
       *)
      Procedure Run; override;
      
      (**
       * Инициализация функции.
       *
       * Параметры:
       *   iPrmCount - Количество необходимых для запуска параметров.
       *   eType     - Тип возвращаемого функцией значения.
       *
       *)
      Procedure Init(iParamCount: integer; eType: TVariableType);
      
      (**
       * Исполнение подпрограммы функции.
       *
       *)
      Procedure Execute;
      
      (**
       * Позволяет получить тело функции.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;
      
      (**
       * Позволяет получить количество необходимых параметров.
       * Только для чтения.
       *
       *)
      Property ParamCount: integer read FPrmCount;
  end;

  (**
   * Класс оператора типа "Подпрограмма". Реализует логику простого подблока операторов.
   * Операторы, сгруппированные между символами { и } можно считать подблоком операторов.
   * Данный подблок выполняется как один оператор в рамках скрипта, при этом подблок является
   * подпрограммой и имет собственный скрипт, который и выполняет во время своего запуска.
   *
   * Метод Run для данного класса просто запускает его подпрограмму. А метод Init фиктивен
   * и присутствует только для обеспечения возможного расширения логики оператора.
   *
   * В исходном коде этот оператор определен констукцией:
   *   { <Operators> };
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TSubscript
   *
   * Ссылочные связи классов:
   *   TSubscript
   *    +- TScript (1:1)
   *
   *)
  TSubScript = class(TConstant)
    Protected
      
      (**
       * Подпрограмма, которую следует выполнить в операторе.
       *
       *)
      FAction: TScript;

    Public
      
      (**
       * Конструктор подблока.
       * Помимо основных действий создает объект скрипта для подпрограммы.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор подблока.
       * Необходим для очистки памяти, занимаемой подпрограммой.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Выдает содержимое оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Интерфейс запуска оператора.
       * Выполняет скрипт подпрограммы.
       *
       *)
      Procedure Run; override;
      
      (**
       * Инициализация оператора.
       * Практически никаких действий не выполняет.
       *
       *)
      Procedure Init;

      (**
       * Позволяет получить ссылку на скрипт подпрограммы.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;

  end;

  (**
   * Класс оператора типа "Вызов функции" (да... и это тоже отдельный оператор).
   * Описание функции - это один оператор и он выполняет одну функцию - определение
   * и регистрацию функции в списках, чтоб она была доступна для вызова.
   * Вызов функции - это исполнение кода функции с конкретно заданными параметрами,
   * это совсем отдельная от описания функции операция и это совершенно отдельный
   * оператор.
   *
   * Вызов функции осуществляется непосредственно с параметрами, метод Run выполняет
   * передачу параметров в функцию и вызывает у функции метод Execute. Метод Init служит
   * для опеределния функции, которую нужно вызвать.  
   *
   * В исходном коде этот оператор определен констукцией:
   *   <FunctionName>( [<Param>[, <Param>]* ]* );
   *
   *   MyFunc(op1, op2);
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TFunctionCall
   *
   * Ссылочные связи классов:
   *   TFunctionCall
   *    +- TFunction (1:1)
   *    +- TVarList  (1:1)
   *
   *)
  TFunctionCall = class(TConstant)
    Protected
      
      (**
       * Функция, вызов которой должен быть выполнен.
       *
       *)
      FFunction: TFunction;
      
      (**
       * Список операторов, которые будут выступать в качестве параметров функции при вызове.
       *
       *)
      FParams: TVarList;

    Public

      (**
       * Конструктор вызова функции.
       * Помимо основных действий создает объект списка параметров.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);

      (**
       * Деструктор Вызова функции.
       * Необходим для удаления содержимого и списка параметров.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Выводит дополнительную информацию о вызове.
       *
       *)
      Function DBGString: string; override;

      (**
       * Интерфейс запуска оператора.
       * Устанавливает значения параметров функции и вызывает метод Execute у функции.
       *
       *)
      Procedure Run; override;
      
      (**
       * Инициализация вызова фунцкии.
       * Устанавливает функцию, которая должна быть выполнена.
       *
       * Параметры:
       *   oFunction - ссылка на объявление функции, которую нужно вызвать.
       *
       *)
      Procedure Init(oFunction: TFunction);

      (**
       * Позволяет считать ссылку на описание вызываемой функции.
       * Только для чтения.
       *
       *)
      Property Func: TFunction read FFunction;
      
      (**
       * Позволяет считать список параметров, с которыми будет вызвана функция.
       *
       *)
      Property Params: TVarList read FParams;
  end;

  (**
   * Класс для базового типа "Операция". Операции в языке могут быть бинарными или унарными.
   * Бинарная операция для своей работы требует два оператора, взаимодействие между которыми и
   * осуществляет.
   * Унарная операция для своей работы требует только один оператор, преобразование
   * которого и осуществляет.
   * Все эти операции лучше всего объединить одним родительским классом - универсальной операцией,
   * которая не имеет логики всоего выполнения, но предоставляет общие характеристики для всех
   * осмысленных операций языка.
   * Функцию универсальной операции и выполняет данный класс.
   *
   * Метод Run в классе фиктивен, он изолирует логику исполнения оператора константы
   * от логики операций. Метод Init служит для определения обоих необходимых операторов.
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *
   * Ссылочные связи классов:
   *   TFunctionCall
   *    +- TConstant (1:1)
   *
   *)
  TOperation = class(TConstant)
    Protected

      (**
       * Ссылка на левый оператор выражения.
       *
       *)
      FLeftOp: TConstant;
      
      (**
       * Ссылка на правый оператор выражения.
       *
       *)
      FRightOp: TConstant;

    Public
      
      (**
       * Инициализация операции.
       * Устанавливает левый и правый операнды выражения.
       *
       * Параметры:
       *   oLeft  - Левый операнд
       *   oRight - Правый операнд
       *
       *)
      Procedure Init(oLeft, oRight: TConstant);
      
      (**
       * Возвращает значение операции в отладочном виде.
       *
       *)
      Function DBGString: string; override;
      
      (**
       * Интерфейс запуска операции.
       * В данном случае метод фиктивен.
       *
       *)
      Procedure Run; override;

  end;

  (**
   * Реализация оператора "Если-тогда-иначе", условного оператора другими словами.
   * Формально, условный оператор выполняет логику своей подпрограммы только тогда, когда
   * его условие возвращает истинный результат. Дополнительно условный оператор может иметь
   * вторую подпрограмму, логика которой может быть выполнена только если условие оператора
   * возвращает ложный результат.
   * Таким образом, если условие истинно, то выполняется основная подпрограмма оператора,
   * а если условие ложно, то выполняется альтернативная подпрограмма, если она определена.
   *
   * Метод Run реализует логику оператора, вызывая одну из подпрограмм в зависимости от
   * возвращаемого условием значения. Метод Init устанавливает выражение, которое следует
   * использовать как условие.
   *
   * В исходном коде этот оператор определен констукцией:
   *   if(<Expression>){ <Operators> }[esle{ <Operators> }];
   *
   *   if(10 > 5){  };
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionIF
   *
   * Ссылочные связи классов:
   *   TFunctionCall
   *    +- TConstant (1:1)
   *    +- TScript   (1:1)
   *
   *)
  TExpressionIF = class(TConstant)
    Protected
      
      (**
       * Ссылка на условие оператора.
       *
       *)
      FCondition: TConstant;
      
      (**
       * Ссылка на подпрограмму, выполняющуюся если условие истинно.
       *
       *)
      FAction: TScript;
      
      (**
       * Ссылка на подпрограмму, выполняющуюся если условие ложно.
       *
       *)
      FAltAction: TScript;

    Public
      
      (**
       * Конструктор оператора.
       * Дополнительно создает скрипты обеих подпрограмм.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Очищает занимаемую подпрограммами память.
       *
       *)
      Destructor Destroy; override;

      (**
       * Возвращает значение оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;
      
      (**
       * Инициализация оператора.
       * Определяет условие оператора.
       *
       *)
      Procedure Init(oCond: TConstant);
     
      (**
       * Интерфейс запуска оператора.
       * Сперва выполняет условие, затем смотрит на его значение, в зависимости
       * от которого выполняет ту или иную подпрограмму.
       *
       *)
       Procedure Run; override;
      
      (**
       * Позволяет получить ссылку на условие оператора.
       *
       *)
      Property Condition: TConstant read FCondition;
      
      (**
       * Позволяет получить ссылку на действие оператора.
       *
       *)
      Property Action: TScript read FAction;
      
      (**
       * Позволяет получить ссылку на альтернативное действие оператора.
       *
       *)
      Property AlterAction: TScript read FAltAction;
  end;

  (**
   * Реализация циклиеского оператора со счетчиком.
   * Цикл for - это счетчик с тремя базовыми операциями: инициализацией, условием выхода
   * и шагом счетчика.
   * Механика выполнения цикла выглядит так:
   *   1- Перед выполнением первого цикла выполняется операция инициализации счетчика.
   *   2- Перед запуском подпрограммы цикла выполняется операция проверки входа в цикл.
   *      Если операция проверки дает ложный результат, выполнение оператора завершается без
   *      выполнения подпрограммы икла. Если условие истинно, то выполняется подпрограмма.
   *   3- После каждого цикла выполняется операция сдвига счетчика и переход к следующему циклу.
   * Подпрограмма цикла является стандартным подблоком операторов, программно реализована все
   * тем же объектом скрипта.
   *
   * Метод Init оператора устанавливает все три базовые операции, а метод Run детально реализует
   * изложенный выше алгоритм.
   *
   * В исходном коде этот оператор определен констукцией:
   *   for(<Initial>; <Condition>; <RevolveAction>){<Operators>};
   *
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionFOR
   *
   * Ссылочные связи классов:
   *   TExpressionFOR
   *    +- TConstant (1:1)
   *    +- TScript   (1:1)
   *
   *)
  TExpressionFOR = class(TConstant)
    Protected
      
      (**
       * Ссылка на операцию инициализации цикла.
       * Во время выполнения выражение вызывается лишь единожды - до входа в самый первый цикл.
       *
       *)
      FInitialAction: TConstant;
      
      (**
       * Ссылка на выражение условия продолжения цикла.
       * Выполняется каждый раз перед исполнением подпрограммы цикла; служит условием,
       * в зависимости от которого выполняется подпрограмма или происходит завершение оператора.
       * Является первой стадией выполнения цикла оператора. Вторая стадия - выполнение
       * подпрограммы.
       *
       *)
      FStepCondition: TConstant;

      (**
       * Ссылка на выражение, изменяющее состояние счетчика цикла.
       * Выражение выполняется только после завершения выполнения подпрограммы цикла.
       * Является третьей стадией выполнения цикла оператора, после которой завершается
       * текущий и начинается новый цикл.
       *
       *)
      FStepAction: TConstant;
      
      (**
       * Ссылка на подпрограмму цикла. Это тело цикла, вторая стадия выполнения цикла оператора.
       *
       *)
      FAction: TScript;

    Public
      
      (**
       * Конструктор оператора.
       * Помимо всего, создает объект подпрограммы цикла.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Необходим для освобождения занимаемой подпрограммой память.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Вывод содержимого оператора в отладочном варианте.
       *
       *)
      Function DBGString: string; override;
      
      (**
       * Инициализация оператора.
       * Определяет все три базовые операции цикла.
       *
       * Параметры:
       *   oInitial - ссылка на операцию инициализации цикла.
       *   oCond    - ссылка на условие выполнения цикла.
       *   oStep    - ссылка на операцию изменения счетчика.
       *
       *)
      Procedure Init(oInitial, oCond, oStep: TConstant);
      
      (**
       * Интерфейс выполнения оператора.
       * Детально реализует алгоритм выполнения цикла, описанный перед объявлением класса.
       *
       *)
      Procedure Run; override;
      
      (**
       * Позволяет полуыить ссылку на подпрограмму выполнения цикла.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;
      
      (**
       * Позволяет получить ссылку на операцию инициализации цикла.
       * Только для чтения.
       *
       *)
      Property InitialAction: TConstant read FInitialAction;
      
      (**
       * Позволяет  получить ссылку на операцию условия выполнения цикла.
       * Только для чтения.
       *
       *)
      Property StepCondition: TConstant read FStepCondition;
      
      (**
       * Позволяет получить ссылку на операцию изменения счетчика.
       * Только для чтения.
       *
       *)
      Property StepAction: TConstant read FStepAction;
  end;

  (**
   * Класс реализации оператора цикла с предусловием. Основой работы цикла является операция
   * условия выполнения. Подпрограмма такого цикла раз за разом будет выполняться, пока его
   * условие не вернет ложный результат, а когда это случится, оператор цикла завершит свою
   * работу.
   * Механизм выполнения оператора примерно таков:
   *   1- Перед выполнением подпрограммы цикла (даже при первом цикле) происходит выполнение
   *      его условия. Если значение словия истинно, оператор переходит к следующему пункту.
   *      Если условие имеет ложный результат, то оператор завершает свою работу.
   *   2- Выполнение подпрограммы цикла.
   *
   * Метод Init оператора определяет условие цикла. Метод Run - детально реализует
   * изложенную логику.
   *
   * В исходном коде этот оператор определен констукцией:
   *   while(<Condition>){<Operators>};
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionWHILE
   *
   * Ссылочные связи классов:
   *   TExpressionWHILE
   *    +- TConstant (1:1)
   *    +- TScript   (1:1)
   *
   *)
  TExpressionWHILE = class(TConstant)
    Protected
      
      (**
       * Ссылка на оператор условия.
       * Этот оператор выполняется всякий раз в начале цикла, от его значения зависит,
       * станет ли оператор выполнять подпрограмму цикл или же завершит свое выполнение.
       *
       *)
      FCondition: TConstant;
      
      (**
       * Ссылка на скрипт подпрограммы цикла.
       * Этот блок операторв является телом цикла.
       *
       *)
      FAction: TScript;

    Public
      
      (**
       * Конструктор опратора.
       * Дополнительно создает объект подпрограммы цикла.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Служит для очистки памяти, занимаемой скрипто подпрограммы.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Возвращает информацию оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Инициализатор оператора.
       * Устанавливает оператор условия.
       *
       * Параметры:
       *   oCond - оператор, который надо будет использовать в качестве условия.
       *
       *)
      Procedure Init(oCond: TConstant);

      (**
       * Интерфейс запуска оператора.
       * Детально реализует изложенную логику работы оператора.
       *
       *)
      Procedure Run; override;

      (**
       * Позволяет получить ссылку на оператор условия.
       * Толкьо для чтения.
       *
       *)
      Property Condition: TConstant read FCondition;

      (**
       * Позволяет получит ссылку на скрипт подпрограммы.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;
  end;

  (**
   * Класс реализации оператора цикла с постусловием. Основой работы цикла является операция
   * условия выполнения. Подпрограмма такого цикла раз за разом будет выполняться, пока его
   * условие не вернет ложный результат, а когда это случится, оператор цикла завершит свою
   * работу.
   * Механизм выполнения оператора примерно таков:
   *   1- Выполняется подпрограмма цикла.
   *   2- Выполняется оператор условия цикла. Если значение условия истинно, то оператор переходит
   *      к началу нового цикла, иначе - завершает свое выполнение.
   *
   * Метод Init оператора определяет условие цикла. Метод Run - детально реализует
   * изложенную логику.
   *
   * В исходном коде этот оператор определен констукцией:
   *   do{<Operators>}while(<Condition>);
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionDO
   *
   * Ссылочные связи классов:
   *   TExpressionDO
   *    +- TConstant (1:1)
   *    +- TScript   (1:1)
   *
   *)
  TExpressionDO = class(TConstant)
    Protected
      
      (**
       * Ссылка на оператор условия.
       * Этот оператор выполняется всякий раз в начале цикла, от его значения зависит,
       * станет ли оператор выполнять подпрограмму цикл или же завершит свое выполнение.
       *
       *)
      FCondition: TConstant;
      
      (**
       * Ссылка на скрипт подпрограммы цикла.
       * Этот блок операторв является телом цикла.
       *
       *)
      FAction: TScript;

    Public
      
      (**
       * Конструктор опратора.
       * Дополнительно создает объект подпрограммы цикла.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Служит для очистки памяти, занимаемой скрипто подпрограммы.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Возвращает информацию оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Инициализатор оператора.
       * Устанавливает оператор условия.
       *
       * Параметры:
       *   oCond - оператор, который надо будет использовать в качестве условия.
       *
       *)
      Procedure Init(oCond: TConstant);
      
      (**
       * Интерфейс запуска оператора.
       * Детально реализует изложенную логику работы оператора.
       *
       *)
      Procedure Run; override;

      (**
       * Позволяет получить ссылку на оператор условия.
       * Толкьо для чтения.
       *
       *)
      Property Condition: TConstant read FCondition;

      (**
       * Позволяет получит ссылку на скрипт подпрограммы.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;
  end;

  (**
   * Класс оператора завершения функции.
   * Любая фунцкия языка может быть остановлена в любой момент ее выполнения. Моментом остановки
   * функции служит ывполнение данного оператора. При вызове оператора так же можно определить
   * выражение, значение которого будет передано как значение выполнения функции.
   * После выполнения данного оператора никакой другой оператор в теле функции более не выполняется
   * и считается, что вызов функции завершен.
   * Оператор работает следующим образом:
   *   1- Первым делом, оператор останавливает выполнение родительского скрипта.
   *      Это делается сбросом флага FScript.FWorkOn в значение false.
   *   2- Далее, переходя по значению TScript.Parent пока не встретится скрипт вызываемой функции,
   *      оператор каждому из скриптов так же сбрасывает флаг FWorkOn, останавливая их выполнение.
   *   3- Затем оператор останавливает выполнение скрипта вызываемой функции.
   *   4- Вызывается выполнение оператора возвращаемого значения, если он был определен. Его
   *      значение передается как значение подпрограммы функции.
   *
   *                                           +--- true --------------------+
   *  Заголовок функции (параметры функции){ <-+  <------ stop ----+         |
   *    ... операторы разные                                     3 |         |
   *    оператор с подпрограммой{ <---------------------- stop ----+         |
   *      ... еще операторы                                    2:1 |         |
   *      оператор с подпрограммой{ <-------------------- stop ----+         |
   *        ... снова операторы                                  1 |         |
   *        return true; +- 1 -> --- остановка выполнения ---------+         |
   *      }              +- 4 -> -------------- передача параметра true -----+
   *    }
   *  }
   *
   * Метод Init оператора позволяет задать прототип функции, в которой он будет вызван, и выражение,
   * значение которого будет передано в качестве результата вызова функции.
   *
   * В исходном коде этот оператор определен констукцией:
   *   return[ <Expression>];
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionRET
   *
   * Ссылочные связи классов:
   *   TExpressionRET
   *    +- TFunction (1:1)
   *    +- TConstant (1:1)
   *
   *)
  TExpressionRET = class(TConstant)
    Protected
      
      (**
       * Ссылка на прототип функции, относительно которого будет работать оператор.
       *
       *)
      FFunction: TFunction;

      (**
       * Выражение, значение которого должно быть передано в качестве значения подпрограммы
       * функции при ее завершении.
       *
       *)
      FExpression: TConstant;

    Public
      
      (**
       * Инициялизация оператора.
       * Определяет прототип функции и возвращаемое выражение.
       *
       * Параметры:
       *   oFunc - Прототип функции, относительно которой должен работать оператор.
       *   oExpr - Выражение, значение которого следует использовать какрезультат выполнения функции
       *
       *)
      Procedure Init(oFunc: TFunction; oExpr: TConstant);
      
      (**
       * Интерфейс выполнения оператора.
       * Выполняет остановку функции и обеспечивает возврат ее значения.
       *
       *)
      Procedure Run; override;
      
      (**
       * Возвращает информацию оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Позволяет получить ссылку на функцию, относительно которой работает оператор
       * Только для чтения.
       *
       *)
      Property RetFunction: TFunction read FFunction;
      
      (**
       * Позволяет получить ссылку на возвращаемое выражение.
       * только для чтения.
       *
       *)
      Property RetExpression: TConstant read FExpression;
  end;

  (**
   * Класс оператора вывода. Единственный оператор, в котором допускается использование строковых
   * данных в виде констант. Оператор является языковой конструкцией с неопределенным числом
   * параметров. Параметры записываются в оператор подобно тому, как записывается вызов функции,
   * они перечисляются через запятую. Во время своего выполнения, оператор формирует значения
   * всех его параметров в единую строку, а затем направляет эту строку в поток вывода.
   *
   * Данный оператор пока не нуждается в инициализации, его метод Init фиктивен и служит только
   * как заглушка. Метод Run последовательно выполняет каждый из параметров, затем присоединяет
   * значение выполненного параметра к результирующей строке, а затем отправляет полученную строку
   * в поток вывода через специальную функцию Echo, описанную в нижней части модуля.
   *
   * В исходном коде этот оператор определен констукцией:
   *   echo(<Expression>, ...);
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionECHO
   *
   * Ссылочные связи классов:
   *   TExpressionECHO
   *    +- TVarList (1:1)
   *
   *)
  TExpressionECHO = class(TConstant)
    Protected

      (**
       * Ссылка на список параметров, операторов, значения которых необходимо вывести.
       *
       *)
      FParams: TVarList;

    Public
      
      (**
       * Конструктор оператора.
       * Дополнительно создает объект списка праметров.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Необходим для очистки памяти, занимаемой списком параметров.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Возвращает информацию оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Интерфейс запуска оператора.
       * Реализует операцию вывода.
       *
       *)
      Procedure Run; override;

      (**
       * Инициализатор оператора.
       * На данный момент фиктивен.
       *
       *)
      Procedure Init;
      
      (**
       * Позволяет получить ссылку на список параметров оператора.
       *
       *)
      Property Params: TVarList read FParams;
  end;

  (**
   * Реализация бинарной операции присваивания.
   * Операция присваивания так же является выражением (Expression) и точно так же во время своего
   * выполнения определяет собственное значение и тип, тип определяется именно во время выполнения
   * операции. Эта особенность делает оператор присваивания рекурсивным и позволяет использовать его
   * как часть общего выражения!
   * В результате, оператор можно использовать в качестве условий, параметров, подоператоров для
   * других операторов языка.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Identifier> = <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationLET
   *
   *)
  TOperationLET = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Сперва выполняет правый операнд, а затем присваивает значению левого операнда
       * значение правого.
       * После этого определяет собственные тип и значение в соответствии с левым операндом.
       *
       * При выполнении оператора используется матрица присваиваний с преобразованием типов
       * CA_LETMATRIX, с помощью которой делается определение необходимой функции.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Реализация оператора сложения. Оператор просто выполняет левый и правый операнды, а затем
   * складывает их значения с учетом типа. Результат сложения записывается в значение оператора.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> + <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationADD
   *
   *)
  TOperationADD = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем складывает их значения.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора вычитания. Работает аналогично сложению, только выполняет операцию вычитания.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> - <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationSUB
   *
   *)
  TOperationSUB = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем вычитает их значения.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора перемножения, выполняется как и любой другой математический оператор.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> * <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationMUL
   *
   *)
  TOperationMUL = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем перемножает их значения.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора диления. Реализует логику целочисленного деления и деления вещественных чисел.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> / <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationDIV
   *
   *)
  TOperationDIV = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет операцию деления.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора целого остатка от деления.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> % <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationMOD
   *
   *)
  TOperationMOD = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет операцию остатка от деления.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "И"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> & <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationAND
   *
   *)
  TOperationAND = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "ИЛИ"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> | <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationOR
   *
   *)
  TOperationOR = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "Исключающее ИЛИ"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> ^ <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationXOR
   *
   *)
  TOperationXOR = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "Больше", "Больше или равно"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> > <Expression>;
   *   <Expression> >= <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationABOVE
   *
   *)
  TOperationABOVE = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "Меньше", "Меньше или равно"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> < <Expression>;
   *   <Expression> <= <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationBELOW
   *
   *)
  TOperationBELOW = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "Эквивалентно", "Не эквивалентно"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> == <Expression>;
   *   <Expression> != <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationEQUAL
   *
   *)
  TOperationEQUAL = class(TOperation)
    Public

      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс унарного логического оператора "НЕ"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   ! <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationNOT
   *
   *)
  TOperationNOT = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;


  (**
   * Вспомогательная структура для определения соответствия приоритета строковому значению
   * определенного оператора.
   *
   *)
  TOperPriority = record
    // Строка, с помощью которой записывается оператор
    Name: string;
    // Условный приоритет, смысл приоритета определяется непосредственно в алгоритме
    Value: byte;
  end;

  (**
   * Тип события вывода на экран.
   * Необъектный вариант события.
   *
   *)
  TEchoEvent = Procedure (sEchoString: string);

  (**
   * Тип события вывода на экран.
   * Объектный вариант события.
   *
   *)
  TObjEchoEvent = Procedure (sEchoString: string) of object;

  (**
   * Возвращает условный приоритет оператора по его строковой записи
   *
   * Параметры:
   *   sOperator - строка, с помощью которой записывается оператор
   *)
  Function GetOperatorOrder(sOperator: string): integer;

  (**
   * Гененрирует вызов события вывода на экран.
   *
   *)
  Procedure Echo(sOut: string);

  (**
   * Гененрирует вызов события вывода ошибки.
   *
   *)
  Procedure ErrorReport(sOut: string);

const
  (**
   * Содержит количество элементов в массиве CA_OPERORDER
   *
   *)
  CI_OPORDERCOUNT: integer = 16;

  (**
   * Содержит записи соответствия символьных записей операторов с их условными приоритетами.
   *
   *)
  CA_OPERORDER: array [0..15] of TOperPriority = (
    (Name: '!';  Value: 200), (Name: '+';  Value:  10), (Name: '-';  Value:  10),
    (Name: '*';  Value:  50), (Name: '/';  Value:  50), (Name: '%';  Value:  50),
    (Name: '&';  Value: 100), (Name: '|';  Value: 100), (Name: '^';  Value: 100),
    (Name: '>';  Value: 100), (Name: '<';  Value: 100), (Name: '=='; Value: 100),
    (Name: '>='; Value: 100), (Name: '<='; Value: 100), (Name: '!='; Value: 100),
    (Name: '=';  Value:   5)
  );

var
  // необъектное событие вывода на экран
  pStdEcho: TEchoEvent = nil;
  // объектное событие вывода на экран
  pObjEcho: TObjEchoEvent = nil;
  // необъектное событие вывода ошибки
  pStdError: TEchoEvent = nil;
  // объектное событие вывода ошибки
  pObjError: TObjEchoEvent = nil;

implementation

uses Math;

Type
  (**
   *
   *
   *)
  TLetOperation = Procedure (var oLeft: TVariableValue; oRight: TVariableValue);

(**
 *
 *
 *)
Function GetOperatorOrder(sOperator: string): integer;
var
  iWalker: integer;
begin
  iWalker := 0;
  Result := 0;
  while (iWalker < CI_OPORDERCOUNT) and (Result = 0) do begin
    if CA_OPERORDER[iWalker].Name = sOperator then Result := CA_OPERORDER[iWalker].Value;
    inc(iWalker);
  end;
end;

(**
 *
 *
 *)
Procedure Echo(sOut: string);
begin
  if assigned(pStdEcho) then begin
    pStdEcho(sOut);
  end else if assigned(pObjEcho) then begin
    pObjEcho(sOut);
  end;
end;

(**
 *
 *
 *)
Procedure ErrorReport(sOut: string); 
begin
  if assigned(pStdError) then begin
    pStdError(sOut);
  end else if assigned(pObjError) then begin
    pObjError(sOut);
  end;
end;

(**
 *
 *
 *)
Procedure LetInt2Int(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := oRight.iValue;
end;

(**
 *
 *
 *)
Procedure LetInt2Float(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.fValue := oRight.iValue;
end;

(**
 *
 *
 *)
Procedure LetInt2Bool(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := 0;
  oLeft.bValue := oRight.iValue <> 0;
end;

(**
 *
 *
 *)
Procedure LetFloat2Int(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := Floor(oRight.fValue);
end;

(**
 *
 *
 *)
Procedure LetFloat2Float(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.fValue := oRight.fValue;
end;

(**
 *
 *
 *)
Procedure LetFloat2Bool(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := 0;
  oLeft.bValue := Floor(oRight.fValue) <> 0;
end;

(**
 *
 *
 *)
Procedure LetBool2Int(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := 0;
  oLeft.bValue := oRight.bValue;
end;

(**
 *
 *
 *)
Procedure LetBool2Float(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.fValue := integer(oRight.bValue);
end;

(**
 *
 *
 *)
Procedure LetBool2Bool(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := 0;
  oLeft.bValue := oRight.bValue;
end;

const
  (**
   *
   *
   *)
  CA_LETMATRIX: array [vtINT..vtBOOL, vtINT..vtBOOL] of TLetOperation = (
    (LetInt2Int,   LetInt2Float,   LetInt2Bool),
    (LetFloat2Int, LetFloat2Float, LetFloat2Bool),
    (LetBool2Int,  LetBool2Float,  LetBool2Bool)
  );

//--------------------------------------------------------------------------------------------------
//--- TBaseOperator class body ---------------------------------------------------------------------
(**
 *
 *
 *)
Constructor TBaseOperator.Create(oScript: TScript; oName: TToken);
begin
  FScript := oScript;
  FScript.Append(Self);
  FName := oName;
  FError := esOK;
  FFlags := [];
end;

(**
 *
 *
 *)
Destructor TBaseOperator.Destroy;
begin
  FScript.Remove(Self);
  inherited Destroy;
end;

(**
 *
 *
 *)
Procedure TBaseOperator.Run;
begin

end;

(**
 *
 *
 *)
Function TBaseOperator.ToString: string;
begin
  Result := '';
end;

(**
 *
 *
 *)
Function TBaseOperator.DBGString: string;
begin
  Result := '';
end;
//--------------------------------------------------------------------------------------------------
//--- TScript class body ---------------------------------------------------------------------------
(**
 *
 *
 *)
Constructor TScript.Create(oParent: TScript);
begin
  FParent := oParent;
  FOperators := TList.Create;
  FVariables := nil;
  FFunctions := nil;
end;

(**
 *
 *
 *)
Destructor TScript.Destroy;
begin
  if FVariables <> nil then FVariables.Free;
  if FFunctions <> nil then FFunctions.Free;
  Clear;
  FOperators.Free;
end;
 
(**
 *
 *
 *)
Procedure TScript.Clear;
begin
  while FOperators.Count > 0 do TBaseOperator(FOperators.Items[0]).Free;
end;
   
(**
 *
 *
 *)
Procedure TScript.Append(oOperator: TBaseOperator);
begin
  if FOperators.IndexOf(oOperator) < 0 then FOperators.Add(oOperator);
end;
  
(**
 *
 *
 *)
Procedure TScript.Remove(oOperator: TBaseOperator);
begin
  FOperators.Remove(oOperator);
end;
  
(**
 *
 *
 *)
Procedure TScript.Delete(iIndex: integer);
begin
  FOperators.Delete(iIndex);
end;
   
(**
 *
 *
 *)
Function TScript.IndexOf(oOperator: TBaseOperator): integer;
begin
  Result := FOperators.IndexOf(oOperator);
end;
   
(**
 *
 *
 *)
Function TScript.Run: boolean;
var
  iWalker: integer;
  oCurrentOp: TBaseOperator;
  bCanRun: boolean;
begin
  Result := false;
  FVariables := TVarList.Create;
  FFunctions := TVarList.Create;

  try
    iWalker := 0;
    FWorkOn := true;
    while (iWalker < FOperators.Count) and FWorkOn do begin
      oCurrentOp := TBaseOperator(FOperators[iWalker]);
      bCanRun := true;
      if oCurrentOp <> nil then begin
        bCanRun := bCanRun and not(ofTraceOff in oCurrentOp.Flags);
        bCanRun := bCanRun and not(ofNotActive in oCurrentOp.Flags);
        if bCanRun then oCurrentOp.Run;
      end;
      inc(iWalker);
    end;
    FWorkOn := false;
    Result := true;
  except
    on oInterruption: Exception do begin
      ErrorReport('[Run time error generated while script work''s]');
      ErrorReport(oInterruption.Message);
      Result := false;
    end;
  end;

  FVariables.Free;
  FFunctions.Free;
  FVariables := nil;
  FFunctions := nil;
end;
   
(**
 *
 *
 *)
Function TScript.GetOperator(iIndex: integer): TBaseOperator;
begin
  Result := nil;
  if iIndex < 0 then exit;
  if FOperators.Count > iIndex then Result := TBaseOperator(FOperators.Items[iIndex]);
end;
   
(**
 *
 *
 *)
Function TScript.GetCount: integer;
begin
  Result := FOperators.Count;
end;
//--------------------------------------------------------------------------------------------------
//--- TConstant class body -------------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TConstant.Init(oValue: TVariableValue; eType: TVariableType);
begin
  FValue := oValue;
  FValueType := eType;
end;
   
(**
 *
 *
 *)
Procedure TConstant.Run;
begin
  if ofNotActive in FFlags then exit;
  FScript.FVariables.Add(Self);
  FFlags := FFlags + [ofNotActive];
end;
    
(**
 *
 *
 *)
Procedure TConstant.SetValue(oValue: TVariableValue);
begin

end;
      
(**
 *
 *
 *)
Function TConstant.GetValue: TVariableValue;
begin
  Result := FValue;
end;
    
(**
 *
 *
 *)
Function TConstant.ToString: string;
begin
  case FValueType of
    vtINT:   Result := Format('%d',[FValue.iValue]);
    vtFLOAT: Result := StringReplace(Format('%f',[FValue.fValue]),',','.',[rfReplaceAll]);
    vtBOOL:  if FValue.bValue = true then Result := 'true' else Result := 'false';
  end;
end;
    
(**
 *
 *
 *)
Function TConstant.DBGString: string;
begin
  case FValueType of
    vtINT:   Result := Format('%d',[FValue.iValue]);
    vtFLOAT: Result := StringReplace(Format('%f',[FValue.fValue]),',','.',[rfReplaceAll]);
    vtBOOL:  if FValue.bValue = true then Result := 'true' else Result := 'false';
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TVariable class body -------------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TVariable.SetValue(oValue: TVariableValue);
begin
  FValue := oValue;
end;
//--------------------------------------------------------------------------------------------------
//--- TSTRConstant class body ----------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TSTRConstant.Init(sValue: string);
begin
  FString := sValue;
  FValueType := vtSTR;
  FFlags := FFlags + [ofNotActive];
end;

(**
 *
 *
 *)
Procedure TSTRConstant.Run;
begin
  if ofNotActive in FFlags then exit;
  FScript.FVariables.Add(Self);
  FFlags := FFlags + [ofNotActive];
end;
     
(**
 *
 *
 *)
Function TSTRConstant.ToString: string;
begin
  Result := FString;
end;
     
(**
 *
 *
 *)
Procedure TSTRConstant.SetValue(sValue: string);
begin

end;
     
(**
 *
 *
 *)
Function TSTRConstant.GetValue: string;
begin
  Result := FString;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperation class body ------------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperation.Init(oLeft, oRight: TConstant);
begin
  FLeftOp := oLeft;
  FRightOp := oRight;
end;
     
(**
 *
 *
 *)
Procedure TOperation.Run;
begin
  if ofNotActive in FFlags then exit;

end;
     
(**
 *
 *
 *)
Function TOperation.DBGString: string;
begin
  Result := '(';
  if FLeftOp <> nil then Result := Result + FLeftOp.DBGString;
  Result := Result + ' ' + FName.Value + ' ';
  if FRightOp <> nil then Result := Result + FRightOp.DBGString;
  Result := Result + ')';
end;
//--------------------------------------------------------------------------------------------------
//--- TFunction class body -------------------------------------------------------------------------

(**
 *
 *
 *)
Constructor TFunction.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);
end;
    
(**
 *
 *
 *)
Destructor TFunction.Destroy;
begin
  FAction.Free;
  inherited Destroy;
end;
     
(**
 *
 *
 *)
Procedure TFunction.Run;
begin
  if ofNotActive in FFlags then exit;
  FScript.FFunctions.Add(Self);
  FFlags := FFlags + [ofNotActive];
end;
      
(**
 *
 *
 *)
Procedure TFunction.Execute;
begin
  FAction.Run;
  FValue := FAction.RetValue;
  FValueType := FAction.RetType;
end;
     
(**
 *
 *
 *)
Procedure TFunction.Init(iParamCount: integer; eType: TVariableType);
begin
  FValue.iValue := 0;
  FValueType := eType;
  FPrmCount := iParamCount;
end;
    
(**
 *
 *
 *)
Function TFunction.DBGString: string;
begin
  Result := Fname.Value+'(){   } ';
end;
//--------------------------------------------------------------------------------------------------
//--- TSubScript class body ------------------------------------------------------------------------

(**
 *
 *
 *)
Constructor TSubScript.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);
  FFlags := [ofNoReturn];
end;
    
(**
 *
 *
 *)
Destructor TSubScript.Destroy;  
begin
  FAction.Free;
  inherited Destroy;
end;
    
(**
 *
 *
 *)
Procedure TSubScript.Run;
begin
  if ofNotActive in FFlags then exit;

  FAction.Run;
  FValue := FAction.RetValue;
  FValueType := FAction.RetType;
end;
    
(**
 *
 *
 *)
Procedure TSubScript.Init;
begin

end;
    
(**
 *
 *
 *)
Function TSubScript.DBGString: string;
begin
  Result := '{ ... }';
end;
//--------------------------------------------------------------------------------------------------
//--- TFunctionCall class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Constructor TFunctionCall.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FParams := TVarList.Create;
end;
    
(**
 *
 *
 *)
Destructor TFunctionCall.Destroy;
begin
  FParams.Clear;
  FParams.Free;
  inherited Destroy;
end;
    
(**
 *
 *
 *)
Procedure TFunctionCall.Run;
var
  iPrmWalker: integer;
  oLeft: TConstant;
  oRight: TConstant;
begin
  if ofNotActive in FFlags then exit;

  try
    iPrmWalker := 0;
    while iPrmWalker < FParams.Count do begin
      oLeft := TConstant(FFunction.Action[iPrmWalker]);
      oRight := FParams[iPrmWalker].Value;
      oRight.Run;
      CA_LETMATRIX[oRight.Typecast, oLeft.Typecast](oLeft.FValue, oRight.Value);
      inc(iPrmWalker);
    end;
    if iPrmWalker < FFunction.ParamCount then raise Exception.Create('Not enough actual parameters to call this one.');
    FFunction.Execute;
    FValue := FFunction.Value;
    FValueType := FFunction.Typecast;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error when calling '+FFunction.DBGString+
        ' ['+IntToStr(FName.Line)+' '+IntToStr(FName.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
     
(**
 *
 *
 *)
Procedure TFunctionCall.Init(oFunction: TFunction);
begin
  FFunction := oFunction;
end;
    
(**
 *
 *
 *)
Function TFunctionCall.DBGString: string;
begin
  Result := FFunction.Name.Value+'(){   } ';
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionIF class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Constructor TExpressionIF.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);
  FAltAction := TScript.Create(oScript);
  FCondition := nil;
end;
   
(**
 *
 *
 *)
Destructor TExpressionIF.Destroy;
begin
  FAction.Free;
  FAltAction.Free;
  inherited Destroy;
end;
   
(**
 *
 *
 *)
Procedure TExpressionIF.Init(oCond: TConstant);
begin
  FCondition := oCond;
  FCondition.Flags := FCondition.Flags + [ofTraceOff];
  FCondition.Flags := FCondition.Flags - [ofNotActive];
end;
   
(**
 *
 *
 *)
Procedure TExpressionIF.Run;
begin
  if ofNotActive in FFlags then exit;

  FCondition.Run;
  if FCondition.Value.bValue then begin
    FAction.Run;
    FValue := FAction.RetValue;
    FValueType := FAction.RetType;
  end else if FAltAction.Count > 0 then begin
    FAltAction.Run;
    FValue := FAltAction.RetValue;
    FValueType := FAltAction.RetType;
  end;
end;
   
(**
 *
 *
 *)
Function TExpressionIF.DBGString: string;
begin
  Result := 'if(' + FCondition.DBGString + '){  }';
  if FAltAction.Count > 0 then begin
    Result := Result + 'else{   }';
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionFOR class body --------------------------------------------------------------------

(**
 *
 *
 *)
Constructor TExpressionFOR.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);
  FInitialAction := nil;
  FStepCondition := nil;
  FStepAction := nil;
end;
   
(**
 *
 *
 *)
Destructor TExpressionFOR.Destroy;
begin
  FAction.Free;
  inherited Destroy;
end;
   
(**
 *
 *
 *)
Procedure TExpressionFOR.Init(oInitial, oCond, oStep: TConstant);
begin
  FInitialAction := oInitial;
  FInitialAction.Flags := FInitialAction.Flags + [ofTraceOff];
  FInitialAction.Flags := FInitialAction.Flags - [ofNotActive];

  FStepCondition := oCond;
  FStepCondition.Flags := FStepCondition.Flags + [ofTraceOff];
  FStepCondition.Flags := FStepCondition.Flags - [ofNotActive];

  FStepAction := oStep;
  FStepAction.Flags := FStepAction.Flags + [ofTraceOff];
  FStepAction.Flags := FStepAction.Flags - [ofNotActive];
end;
  
(**
 *
 *
 *)
Procedure TExpressionFOR.Run;
var
  bStepFlag: boolean;
begin
  if ofNotActive in FFlags then exit;

  if FInitialAction <> nil then FInitialAction.Run;
  if FStepCondition <> nil then begin
    FStepCondition.Run;
    bStepFlag := FStepCondition.Value.bValue;
  end else bStepFlag := true;
  while bStepFlag do begin
    FAction.Run;
    if FStepAction <> nil then FStepAction.Run;
    if FStepCondition <> nil then begin
      FStepCondition.Run;
      bStepFlag := FStepCondition.Value.bValue;
    end;
  end;
  FValue := FAction.RetValue;
  FValueType := FAction.RetType;
end;
   
(**
 *
 *
 *)
Function TExpressionFOR.DBGString: string;
begin
  Result := 'for(';
  if FInitialAction <> nil then Result := Result + FInitialAction.DBGString;
  Result := Result + '; ';
  if FStepCondition <> nil then Result := Result + FStepCondition.DBGString;
  Result := Result + '; ';
  if FStepAction <> nil then Result := Result + FStepAction.DBGString;
  Result := Result + '){  }';
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionWHILE class body ------------------------------------------------------------------

(**
 *
 *
 *)
Constructor TExpressionWHILE.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);
  FCondition := nil;
end;
   
(**
 *
 *
 *)
Destructor TExpressionWHILE.Destroy;
begin
  FAction.Free;
  inherited Destroy;
end;
   
(**
 *
 *
 *)
Procedure TExpressionWHILE.Init(oCond: TConstant);
begin
  FCondition := oCond;
  FCondition.Flags := FCondition.Flags + [ofTraceOff];
  FCondition.Flags := FCondition.Flags - [ofNotActive];
end;
   
(**
 *
 *
 *)
Procedure TExpressionWHILE.Run;
begin
  if ofNotActive in FFlags then exit;

  FCondition.Run;
  while FCondition.Value.bValue do begin
    FAction.Run;
    FCondition.Run;
  end;
  FValue := FAction.RetValue;
  FValueType := FAction.RetType;
end;
    
(**
 *
 *
 *)
Function TExpressionWHILE.DBGString: string;
begin
  Result := 'while('+FCondition.DBGString+'){   } ';
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionDO class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Constructor TExpressionDO.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);
  FCondition := nil;
end;
   
(**
 *
 *
 *)
Destructor TExpressionDO.Destroy;
begin
  FAction.Free;
  inherited Destroy;
end;
   
(**
 *
 *
 *)
Procedure TExpressionDO.Init(oCond: TConstant);
begin
  FCondition := oCond;
  FCondition.Flags := FCondition.Flags + [ofTraceOff];
  FCondition.Flags := FCondition.Flags - [ofNotActive];
end;
   
(**
 *
 *
 *)
Procedure TExpressionDO.Run;
begin
  if ofNotActive in FFlags then exit;

  repeat
    FAction.Run;
    FCondition.Run;
  until not FCondition.Value.bValue;
  FValue := FAction.RetValue;
  FValueType := FAction.RetType;
end;
   
(**
 *
 *
 *)
Function TExpressionDO.DBGString: string;
begin
  Result := 'do{ }while('+FCondition.DBGString+')';
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionRET class body --------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TExpressionRET.Init(oFunc: TFunction; oExpr: TConstant);
begin
  FFunction := oFunc;
  FExpression := oExpr;
  FExpression.Flags := FExpression.Flags + [ofTraceOff];
  FExpression.Flags := FExpression.Flags - [ofNotActive];
end;
   
(**
 *
 *
 *)
Procedure TExpressionRET.Run;
var
  oScript: TScript;
begin
  if ofNotActive in FFlags then exit;

  oScript := FScript;
  while oScript <> FFunction.Action do begin
    oScript.FWorkOn := false;
    oScript := oScript.Parent;
  end;
  oScript.FWorkOn := false;
  FFunction.Action.FWorkOn := false;
  FExpression.Run;
  FFunction.FAction.FValue := FExpression.Value;
  FFunction.FAction.FValueType := FExpression.Typecast;
end;
  
(**
 *
 *
 *)
Function TExpressionRET.DBGString: string;
begin
  Result := 'return ' + FExpression.DBGString;
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionECHO class body -------------------------------------------------------------------

(**
 *
 *
 *)
Constructor TExpressionECHO.Create(oScript: TScript; oName: TToken);  
begin
  inherited Create(oScript, oName);
  FParams := TVarList.Create;
end;
   
(**
 *
 *
 *)
Destructor TExpressionECHO.Destroy;
begin
  FParams.Clear;
  FParams.Free;
  inherited Destroy;
end;
   
(**
 *
 *
 *)
Procedure TExpressionECHO.Run;
var
  iWalker: integer;
  sOutStr: string;
begin
  if ofNotActive in FFlags then exit;
  
  sOutStr := '';
  iWalker := 0;
  while iWalker < FParams.Count do begin
    FParams[iWalker].Value.Run;
    sOutStr := sOutStr + FParams[iWalker].Value.ToString;
    inc(iWalker);
  end;
  Echo(sOutStr);
end;
  
(**
 *
 *
 *)
Procedure TExpressionECHO.Init;
begin

end; 
  
(**
 *
 *
 *)
Function TExpressionECHO.DBGString: string;
begin
  Result := 'echo()';
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationLET class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationLET.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FRightOp.Run;
    CA_LETMATRIX[FRightOp.Typecast, FLeftOp.Typecast](FLeftOp.FValue, FRightOp.Value);
    FValue := FLeftOp.FValue;
    FValueType := FLeftOp.Typecast;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationADD class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationADD.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;
    FRightOp.Run;
    case FLeftOp.Typecast of
      vtINT: begin
        case FRightOp.Typecast of
          vtINT: begin
            FValueType := vtINT;
            FValue.iValue := FLeftOp.Value.iValue + FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValueType := vtFLOAT;
            FValue.fValue := FLeftOp.Value.iValue + FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValueType := vtINT;
            FValue.iValue := FLeftOp.Value.iValue + integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtFLOAT: begin
        FValueType := vtFLOAT;
        case FRightOp.Typecast of
          vtINT: begin
            FValue.fValue := FLeftOp.Value.fValue + FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValue.fValue := FLeftOp.Value.fValue + FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValue.fValue := FLeftOp.Value.fValue + integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtBOOL: begin
        case FRightOp.Typecast of
          vtINT: begin
            FValueType := vtINT;
            FValue.iValue := integer(FLeftOp.Value.bValue) + FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValueType := vtFLOAT;
            FValue.fValue := integer(FLeftOp.Value.bValue) + FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValueType := vtINT;
            FValue.iValue := integer(FLeftOp.Value.bValue) + integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+Fname.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationSUB class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationSUB.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;
    FRightOp.Run;
    case FLeftOp.Typecast of
      vtINT: begin
        case FRightOp.Typecast of
          vtINT: begin
            FValueType := vtINT;
            FValue.iValue := FLeftOp.Value.iValue - FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValueType := vtFLOAT;
            FValue.fValue := FLeftOp.Value.iValue - FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValueType := vtINT;
            FValue.iValue := FLeftOp.Value.iValue - integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtFLOAT: begin
        FValueType := vtFLOAT;
        case FRightOp.Typecast of
          vtINT: begin
            FValue.fValue := FLeftOp.Value.fValue - FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValue.fValue := FLeftOp.Value.fValue - FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValue.fValue := FLeftOp.Value.fValue - integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtBOOL: begin
        case FRightOp.Typecast of
          vtINT: begin
            FValueType := vtINT;
            FValue.iValue := integer(FLeftOp.Value.bValue) - FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValueType := vtFLOAT;
            FValue.fValue := integer(FLeftOp.Value.bValue) - FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValueType := vtINT;
            FValue.iValue := integer(FLeftOp.Value.bValue) - integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationMUL class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationMUL.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;
    FRightOp.Run;
    case FLeftOp.Typecast of
      vtINT: begin
        case FRightOp.Typecast of
          vtINT: begin
            FValueType := vtINT;
            FValue.iValue := FLeftOp.Value.iValue * FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValueType := vtFLOAT;
            FValue.fValue := FLeftOp.Value.iValue * FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValueType := vtINT;
            FValue.iValue := FLeftOp.Value.iValue * integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtFLOAT: begin
        FValueType := vtFLOAT;
        case FRightOp.Typecast of
          vtINT: begin
            FValue.fValue := FLeftOp.Value.fValue * FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValue.fValue := FLeftOp.Value.fValue * FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValue.fValue := FLeftOp.Value.fValue * integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtBOOL: begin
        case FRightOp.Typecast of
          vtINT: begin
            FValueType := vtINT;
            FValue.iValue := integer(FLeftOp.Value.bValue) * FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValueType := vtFLOAT;
            FValue.fValue := integer(FLeftOp.Value.bValue) * FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValueType := vtINT;
            FValue.iValue := integer(FLeftOp.Value.bValue) * integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationDIV class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationDIV.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;
    FRightOp.Run;
    case FLeftOp.Typecast of
      vtINT: begin
        case FRightOp.Typecast of
          vtINT: begin
            FValueType := vtINT;
            FValue.iValue := FLeftOp.Value.iValue div FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValueType := vtFLOAT;
            FValue.fValue := FLeftOp.Value.iValue / FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValueType := vtINT;
            FValue.iValue := FLeftOp.Value.iValue div integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtFLOAT: begin
        FValueType := vtFLOAT;
        case FRightOp.Typecast of
          vtINT: begin
            FValue.fValue := FLeftOp.Value.fValue / FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValue.fValue := FLeftOp.Value.fValue / FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValue.fValue := FLeftOp.Value.fValue / integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtBOOL: begin
        case FRightOp.Typecast of
          vtINT: begin
            FValueType := vtINT;
            FValue.iValue := integer(FLeftOp.Value.bValue) div FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValueType := vtFLOAT;
            FValue.fValue := integer(FLeftOp.Value.bValue) / FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValueType := vtINT;
            FValue.iValue := integer(FLeftOp.Value.bValue) div integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationMOD class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationMOD.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;
    FRightOp.Run;
    FValueType := vtINT;
    if (FLeftOp.Typecast = vtFlOAT) or (FRightOp.Typecast = vtFLOAT) then begin
      raise Exception.Create('"Remainder" operation can''t be applied with float values');
    end;
    case FLeftOp.Typecast of
      vtINT: begin
        case FRightOp.Typecast of
          vtINT: begin
            FValue.iValue := FLeftOp.Value.iValue mod FRightOp.Value.iValue;
          end;
          vtBOOL: begin
            FValue.iValue := FLeftOp.Value.iValue mod integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtBOOL: begin
        FValue.iValue := 0;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationAND class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationAND.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;
    FRightOp.Run;
    FValueType := vtBOOL;
    FValue.bValue := FLeftOp.Value.bValue and FRightOp.Value.bValue;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationOR class body ----------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationOR.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;
    FRightOp.Run;
    FValueType := vtBOOL;
    FValue.bValue := FLeftOp.Value.bValue or FRightOp.Value.bValue;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationNOT class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationNOT.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;
    FValueType := vtBOOL;
    FValue.bValue := not FLeftOp.Value.bValue;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationXOR class body ---------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationXOR.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;
    FRightOp.Run;
    FValueType := vtBOOL;
    FValue.bValue := FLeftOp.Value.bValue xor FRightOp.Value.bValue;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationABOVE class body -------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationABOVE.Run;
var
  bTestEqual: boolean;
begin
  if ofNotActive in FFlags then exit;

  try
    bTestEqual := FName.Value = '>=';
    FLeftOp.Run;
    FRightOp.Run;
    FValueType := vtBOOL;
    FValue.iValue := 0;
    case FLeftOp.Typecast of
      vtINT: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue >= FRightOp.Value.iValue
            else FValue.bValue := FLeftOp.Value.iValue > FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue >= Floor(FRightOp.Value.fValue)
            else FValue.bValue := FLeftOp.Value.iValue > Floor(FRightOp.Value.fValue);
          end;
          vtBOOL: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue >= integer(FRightOp.Value.bValue)
            else FValue.bValue := FLeftOp.Value.iValue > integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtFLOAT: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestEqual then FValue.bValue := Floor(FLeftOp.Value.fValue) >= FRightOp.Value.iValue
            else FValue.bValue := Floor(FLeftOp.Value.fValue) > FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.fValue >= FRightOp.Value.fValue
            else FValue.bValue := FLeftOp.Value.fValue > FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            if bTestEqual then FValue.bValue := Floor(FLeftOp.Value.fValue) >= integer(FRightOp.Value.bValue)
            else FValue.bValue := Floor(FLeftOp.Value.fValue) > integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtBOOL: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) >= FRightOp.Value.iValue
            else FValue.bValue := integer(FLeftOp.Value.bValue) > FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) >= Floor(FRightOp.Value.fValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) > Floor(FRightOp.Value.fValue);
          end;
          vtBOOL: begin
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) >= integer(FRightOp.Value.bValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) > integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationBELOW class body -------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationBELOW.Run;
var
  bTestEqual: boolean;
begin
  if ofNotActive in FFlags then exit;

  try
    bTestEqual := FName.Value = '<=';
    FLeftOp.Run;
    FRightOp.Run;
    FValueType := vtBOOL;
    FValue.iValue := 0;
    case FLeftOp.Typecast of
      vtINT: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue <= FRightOp.Value.iValue
            else FValue.bValue := FLeftOp.Value.iValue < FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue <= Floor(FRightOp.Value.fValue)
            else FValue.bValue := FLeftOp.Value.iValue < Floor(FRightOp.Value.fValue);
          end;
          vtBOOL: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue <= integer(FRightOp.Value.bValue)
            else FValue.bValue := FLeftOp.Value.iValue < integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtFLOAT: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestEqual then FValue.bValue := Floor(FLeftOp.Value.fValue) <= FRightOp.Value.iValue
            else FValue.bValue := Floor(FLeftOp.Value.fValue) < FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.fValue <= FRightOp.Value.fValue
            else FValue.bValue := FLeftOp.Value.fValue < FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            if bTestEqual then FValue.bValue := Floor(FLeftOp.Value.fValue) <= integer(FRightOp.Value.bValue)
            else FValue.bValue := Floor(FLeftOp.Value.fValue) < integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtBOOL: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) <= FRightOp.Value.iValue
            else FValue.bValue := integer(FLeftOp.Value.bValue) < FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) <= Floor(FRightOp.Value.fValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) < Floor(FRightOp.Value.fValue);
          end;
          vtBOOL: begin
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) <= integer(FRightOp.Value.bValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) < integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationEQUAL class body -------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationEQUAL.Run;
var
  bTestRevert: boolean;
begin
  if ofNotActive in FFlags then exit;

  try
    bTestRevert := FName.Value = '!=';
    FLeftOp.Run;
    FRightOp.Run;
    FValueType := vtBOOL;
    FValue.iValue := 0;
    case FLeftOp.Typecast of
      vtINT: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestRevert then FValue.bValue := FLeftOp.Value.iValue <> FRightOp.Value.iValue
            else FValue.bValue := FLeftOp.Value.iValue = FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestRevert then FValue.bValue := FLeftOp.Value.iValue <> Floor(FRightOp.Value.fValue)
            else FValue.bValue := FLeftOp.Value.iValue = Floor(FRightOp.Value.fValue);
          end;
          vtBOOL: begin
            if bTestRevert then FValue.bValue := FLeftOp.Value.iValue <> integer(FRightOp.Value.bValue)
            else FValue.bValue := FLeftOp.Value.iValue = integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtFLOAT: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestRevert then FValue.bValue := Floor(FLeftOp.Value.fValue) <> FRightOp.Value.iValue
            else FValue.bValue := Floor(FLeftOp.Value.fValue) = FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestRevert then FValue.bValue := FLeftOp.Value.fValue <> FRightOp.Value.fValue
            else FValue.bValue := FLeftOp.Value.fValue < FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            if bTestRevert then FValue.bValue := Floor(FLeftOp.Value.fValue) <> integer(FRightOp.Value.bValue)
            else FValue.bValue := Floor(FLeftOp.Value.fValue) = integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtBOOL: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestRevert then FValue.bValue := integer(FLeftOp.Value.bValue) <> FRightOp.Value.iValue
            else FValue.bValue := integer(FLeftOp.Value.bValue) = FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestRevert then FValue.bValue := integer(FLeftOp.Value.bValue) <> Floor(FRightOp.Value.fValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) = Floor(FRightOp.Value.fValue);
          end;
          vtBOOL: begin
            if bTestRevert then FValue.bValue := integer(FLeftOp.Value.bValue) <> integer(FRightOp.Value.bValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) = integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TVarList class body --------------------------------------------------------------------------

(**
 *
 *
 *)
constructor TVarList.Create;  
begin
  FList := TList.Create;
end;
   
(**
 *
 *
 *)
Destructor TVarList.Destroy;     
begin
  Clear;
  FList.Free;
end;
  
(**
 *
 *
 *)
Procedure TVarList.Clear;           
begin
  while FList.Count > 0 do TVarListItem(FList.Items[0]).Free;
end;
  
(**
 *
 *
 *)
Procedure TVarList.Add(oVar: TConstant);
begin
  TVarListItem.Create(Self, oVar);
end;
   
(**
 *
 *
 *)
Procedure TVarList.Remove(oVar: TConstant);
var
  oItem: TVarListItem;
begin
  oItem := FindVar(oVar.Name);
  if oItem <> nil then oItem.Free;
end;
  
(**
 *
 *
 *)
Function TVarList.FindVar(oName: TToken): TVarListItem;
var
  iWalk: integer;
begin
  iWalk := 0;
  Result := nil;
  while FList.Count > iWalk do begin
    if TVarListItem(FList.Items[iWalk]).Value.Name.Value = oName.Value then begin
      Result := TVarListItem(FList.Items[iWalk]);
      break;
    end;
    inc(iWalk);
  end;
end;
  
(**
 *
 *
 *)
Procedure TVarList.AddVar(oVar: TVarListItem);  
begin
  FList.Add(oVar);
end;
  
(**
 *
 *
 *)
Procedure TVarList.RemVar(oVar: TVarListItem);
begin
  FList.Remove(oVar);
end;
 
(**
 *
 *
 *)
Function TVarList.GetVar(iIndex: integer): TVarListItem;
begin
  if (iIndex >= 0) and (FList.Count > iIndex) then Result := TVarListItem(FList.Items[iIndex])
  else Result := nil;
end;
   
(**
 *
 *
 *)
FUnction TVarList.GetCount: integer;
begin
  Result := FList.Count;
end;
//--------------------------------------------------------------------------------------------------
//--- TVarListItem ---------------------------------------------------------------------------------

(**
 *
 *
 *)
constructor TVarListItem.Create(oParent: TVarList; oValue: TConstant);
begin
  FParent := oParent;
  FParent.AddVar(Self);
  FValue := oValue;
end;
  
(**
 *
 *
 *)
destructor TVarListItem.Destroy;
begin
  FParent.RemVar(Self);
  inherited Destroy;
end;
//--------------------------------------------------------------------------------------------------
end.
