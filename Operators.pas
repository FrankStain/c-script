unit operators;
(**
 * Модуль операторов языка. Содержит классы, выполняющие роль определенных операторов,
 * для построения модели программы.
 *
 * Модель программы состоит из так называемого скрипта (script) и включенных в скрипт операторов.
 * При чем любой оператор так же может иметь подчиненный скрипт, что отображает иерархическую связь
 * между операторами (когда операторы могет группироваться в подблоки под управлением какого либо
 * иного оператора, как подблок относительно оператора if, или как тело функции относительно ее
 * заголовка).
 *
 * Модель отобразить можно так:
 *    Скрипт
 *     +- Оператор
 *     +  ...
 *     +- Оператор
 *     |   +- Скрипт
 *     +- Оператор
 *     +  ...
 *
 * Выполняясь, модель реализует непосредственную цель исходного кода - логические расчеты.
 * Выполнение модели - это последовательное, пошаговое выполнение каждого из ее операторов.
 * В том случае, если во время выполнения оператор не может логически закончить свою работу,
 * оператор генерирует состояние ошибки. Это состояние распространяется на скрипт, которому
 * пренадлежит оператор с ошибкой, и останавливает его работу.
 * В случае, если скрипт является подблоком какого либо оператора, состояние ошибки
 * распространяется и на сам оператор, подблоком которого является ошибочный скрипт, что приведет
 * к генерации ошибки самого оператора. И так далее.
 *
 * К состоянию ошибки одного оператора применимо правило математической индукции: в случае
 * возникновения ошибки в одном операторе, вне зависимости от степени вложенности оператора
 * относительно основного скрипта, весь процесс выполнения останавливается, а состояние
 * ошибки передается на самый верхний уровень.
 *
 * Общая иерархия классов модуля:
 *   TObject
 *    +- TBaseOperator
 *    |   +- TConstant
 *    |   |   +- TVariable
 *    |   |   +- TSTRConstant
 *    |   |   +- TFunction
 *    |   |   +- TSubScript
 *    |   |   +- TFunctionCall
 *    |   |   +- TOperation
 *    |   |   |   +- TOperationADD
 *    |   |   |   +- TOperationSUB
 *    |   |   |   +- TOperationMUL
 *    |   |   |   +- TOperationDIV
 *    |   |   |   +- TOperationMOD
 *    |   |   |   +- TOperationAND
 *    |   |   |   +- TOperationOR
 *    |   |   |   +- TOperationXOR
 *    |   |   |   +- TOperationABOVE
 *    |   |   |   +- TOperationBELOW
 *    |   |   |   +- TOperationEQUAL
 *    |   |   |   +- TOperationNOT
 *    |   |   |
 *    |   |   +- TExpressionIF
 *    |   |   +- TExpressionWHILE
 *    |   |   +- TExpressionDO
 *    |   |   +- TExpressionRET
 *    |   |   +- TExpressionECHO
 *    |   |
 *    |   x
 *    |
 *    +- TScript
 *    +- TVarList
 *    +- TVarListItem
 *
 *)

interface

uses
  Windows, Classes,
//--- Собственные модули ---------------------------------------------------------------------------
  TextMessages, tokenizer,
//--------------------------------------------------------------------------------------------------
  SysUtils;

Type
  (**
   * Перечисление допустимых типов данных
   *
   *)
  TVariableType = (
    vtUndef = 0,     // Неопределенный тип
    vtINT,           // Тип целого знакового числа
    vtFLOAT,         // Тип вещественного числа
    vtBOOL,          // Тип булевского значения (true / false)
    vtSTR            // Тип строкового значения
  );

  (**
   * Тип для хранения значения, для хранения значений разных типов используется механизм
   * объединения полей записи.
   *
   * В одно время может хранить только одно значение, но представить его может в любом
   * из трех базовых видов: int, float или bool
   * Представление значения производится без приведения типов.
   *
   * Размер записи составляет 4 байта.
   *
   *)
  TVariableValue = record
    case Byte of
      0: (iValue: integer);  // 4б. Для хранения данных в виде простого целого со знаком
      1: (fValue: single);   // 4б. Для хранения данных в виде вещественного числа
      2: (bValue: boolean);  // 1б. Для хранения данных в виде булевского значения.
  end;

  (**
   * Предопределение типов скрипта и константы, необходимо для перекрестной увязки типов.
   *
   *)
  TScript = class;
  TConstant = class;

  (**
   * Перечисление дополнительных опций оператора.
   * Служит для наделения конкретного оператора особыми свойствами.
   *
   *)
  TOperatorFlag = (
    ofNotActive,    // Метод Run оператора не будет выполнять свою логику
    ofNoReturn,     // Функция не останавливается по оператору return
    ofTraceOff,     // Скрипт не должен запускать метод Run у данного оператора
    ofMakeAssert,   // Реализовать assert при выполнении данного оператора (подсказка для дебага)
    ofBreakpoint,   // Реализовать остановку скрипта и переход в режим пошаговой отладки на данном операторе
    ofInitialized,  // Данный оператор уже выполнил свою инициализацию, используется при выполнеии оператора
    ofElseAssigned, // Флаг ставится на этапе анализа синтаксиса, говорит о завершенности блока if-else
    ofDoAssigned    // Флаг ставится во время анализа синтаксиса, говорит о завершенности блока do-while
  );
  // Контейнер для содержания нескольких опций в одном операторе.
  TOperatorFlags = set of TOperatorFlag;

  (**
   * Класс базового оператора. Никакой логики, только служебный интерфейс и поля.
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *
   * Ссылочные связи классов:
   *   TBaseOperator
   *    +- TScript (1:1)
   *    +- TToken  (1:1)
   *
   *)
  TBaseOperator = class
    Protected
      (**
       * Ссылка на родительский скрипт, которому пренадлежит данный оператор.
       * При создании объекта оператора, он самостоятельно регистрируется в
       * родительском скрипте.
       *
       *)
      FScript: TScript;

      (**
       * Набор опций оператора.
       *
       *)
      FFlags: TOperatorFlags;

      (**
       * Ссылка на лексему, имя данного оператора.
       * При работе с исходным кодом необходимо не только знать строчку лексемы,
       * которой порожден данный оператор, но и ее место в исходном коде,
       * а так же тип лексемы.
       * Поэтому гораздо лучше будет сделать именно связь оператора с лексемой
       * из лексического анализатора.
       *
       *)
      FName: TToken;

      (**
       * Состояние ошибки оператора.
       *
       *)
      FError: TParserErrorState;

    Public
      (**
       * Конструктор оператора.
       * Создает сам оператор, определяет для него родительский скрипт и имя,
       * производит регистрацию данного оператора в родительском скрипте.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);

      (**
       * Деструктор оператора.
       * Удаляет подчиненные объекты и занятую в работе память, снимает регистрацию в
       * родительском скрипте.
       *
       *)
      Destructor Destroy; override;

      (**
       * Интерфейс запуска оператора.
       * Метод перегружается в дочерних классах для реализации логики конкретного операора.
       *
       *)
      Procedure Run; virtual;

      (**
       * Позволяет получить из оператора его строковое представление.
       *
       * Возвращает строку, символизирующую значение константы.
       *
       *)
      Function ToString: string; virtual;
      
      (**
       * Позволяет получить запись оператора в отладочном варианте.
       *
       * Возвращает строку, обоначающую значение константы в отладочном виде.
       *
       *)
      Function DBGString: string; virtual;

      (**
       * Свойство, позволяющее считать ссылку на родительский скрипт оператора.
       * Свойство только для читния.
       *
       *)
      Property Script: TScript read FScript;

      (**
       * Свойство для считывания состояния ошибки оператора.
       * Свойство только для чтения.
       *
       *)
      Property Error: TParserErrorState read FError;

      (**
       * Свойство для чтения имени оператора.
       * Свойство только для чтения.
       *
       *)
      Property Name: TToken read FName;

      (**
       * Свойство для доступа к флагам оператора.
       * Свойство для чтения и записи.
       *
       *)
      Property Flags: TOperatorFlags read FFlags write FFlags;
  end;

  (**
   * Предопределение элемента списка операторов
   *
   *)
  TVarListItem = class;

  (**
   * Класс списка переменных. Реализует методы для хранения в стиле FIFO необходимых
   * операторов скрипта.
   * Применяется для хранения ссылок уже зарегистрированных переменных и функций, по отдельности.
   *
   * Иерархия классов:
   *   TObject
   *    +- TVarList
   *
   * Ссылочные связи классов:
   *   TVarList
   *    +- TVarListItem (1:M)
   *
   *)
  TVarList = class
    Private
      (**
       * Хранилище ссылок.
       *
       *)
      FList: TList;

    Protected
      (**
       * Метод служит для регистрации элемента в хранилище.
       * Элемент сам вызывает этот метод в собственном конструкторе.
       *
       * Параметры:
       *   oVar - элемент списка, который необходимо зарегистрировать
       *
       *)
      Procedure AddVar(oVar: TVarListItem);

      (**
       * Метод снимает регистрацию элемента в хранилище.
       * Вызывается в деструкторе элемента списка.
       *
       * Параметры:
       *   oVar - элемент списка, который нужно снять с регистрации
       *
       *)
      Procedure RemVar(oVar: TVarListItem);

      (**
       * Возвращает элемент списка по его числовому индексу.
       *
       * Параметры:
       *   iIndex - индекс элемента в хранилище, самый первый элемент имеет индекс 0
       *
       * Возвращает ссылку на элемент списка или nil, если по данному индексу нет элемента
       *
       *)
      Function GetVar(iIndex: integer): TVarListItem;

      (**
       * Определяет количество элементов в хранилище.
       *
       * Возвращает целое число, количество элементов в хранилище
       *
       *)
      FUnction GetCount: integer;

    Public

      (**
       * Конструктор списка.
       *
       *)
      Constructor Create;

      (**
       * Деструктор списка.
       *
       *)
      Destructor Destroy; override;

      (**
       * Полная очистка списка.
       *
       *)
      Procedure Clear;

      (**
       * Регистрирует оператор скрипта в хранилище.
       *
       * Параметры:
       *   oVar - оператор скрипта. который нужно добавить в хранилище
       *
       *)
      Procedure Add(oVar: TConstant);

      (**
       * Удаляет оператор из хранилища
       *
       * Параметры:
       *   oVar - оператор скрипта, который необходимо удалить из хранилища
       *)
      Procedure Remove(oVar: TConstant);

      (**
       * Выполняет поиск оператора по его имени.
       *
       * Параметры:
       *   oName - лексема, по значению которой необходимо в хранилище найти оператор
       *
       * Возвращает элемент списка, в значении которого необходимый оператор, или nil,
       * если ничего не нашлось.
       *
       *)
      Function FindVar(oName: TToken): TVarListItem;

      (**
       * Свойство возвращает число элементов в хранилище на данный момент.
       * Только для чтения.
       *
       *)
      Property Count: integer read GetCount;

      (**
       * Войство для получения элемента списка по индексу.
       * Только для чтения. Является свойством по умолчанию.
       *
       *)
      Property List[iIndex: integer]: TVarListItem read GetVar; default;
  end;

  (**
   * Класс элемента списка операторов.
   * Самостоятельно регистрируется в хранилище списка операторов.
   * Самостоятельно снимается с регистрации.
   * Предоставляет интерфейс для хранения оператора в списке.
   *
   * Иерархия классов:
   *   TObject
   *    +- TVarListItem
   *
   * Ссылочные связи классов:
   *   TVarListItem
   *    +- TVarList  (1:1)
   *    +- TConstant (1:1)
   *
   *)
  TVarListItem = class
    Private

      (**
       * Ссылка на хозяина, список, в хранилище которого зарегистрирован элемент.
       *
       *)
      FParent: TVarList;

      (**
       * Ссылка на оператор, для которого заведен данный элемент списка.
       *
       *)
      FValue: TConstant;

    Public

      (**
       * Конструктор элемента списка.
       * Устанавливает хозяина И оператор для нового элемента.
       * Осуществляет регистрацию в хранилище хозяина.
       *
       * Параметры:
       *   oParent - ссылка на список, в котором будет содержаться данный элемент.
       *   oValue - оператор скрипта, для которого заводится данный элемент.
       *
       *)
      Constructor Create(oParent: TVarList; oValue: TConstant);

      (**
       * Деструктор элемента.
       * Снимает элемент с регистрации в хранилище хозяина.
       *
       *)
      Destructor Destroy; override;

      (**
       * Свойство позволяет считать ссылку на хозяина данного элемента.
       * Свойство только для чтения.
       *
       *)
      Property Parent: TVarList read FParent;

      (**
       * Свойство позволяет считать оператор скрипта из данного элемента.
       * Свойство только для чтения.
       *
       *)
      Property Value: TConstant read FValue;
  end;

  (**
   * Класс самого скрипта, основа модели исполняемого кода.
   *
   * Иерархия классов:
   *   TObject
   *    +- TScript
   *
   * Ссылочные связи классов:
   *   TScript
   *    +- TBaseOperator (1:M)
   *    +- TScript       (1:1)
   *    +- TVarList      (1:1)
   *    
   *)
  TScript = class
    Private

      (**
       * Ссылка на родительский скрипт. Считать можно так: если данное поле равно nil,
       * значит это есть основной скрипт программы.
       *
       *)
      FParent: TScript;

      (**
       * Хранилище операторов данного скрипта.
       *
       *)
      FOperators: TList;
      
      (**
       * Значение, возвращаемое скриптом. Используется не всегда.
       *
       *)
      FValue: TVariableValue;

      (**
       * Тип возвращаемого значения.
       *
       *)
      FValueType: TVariableType;

      (**
       * Флаг "Скрипт в работе", если этот флаг сбросить, скрипт остановится.
       *
       *)
      FWorkOn: boolean;

      (**
       * Хранилище инициализированных переменных.
       *
       *)
      FVariables: TVarList;

      (**
       * Хранилище объявленных функций
       *
       *)
      FFunctions: TVarList;

    Protected
      
      (**
       * Возвращает оператор из хранилища по его индексу
       *
       * Параметры:
       *   iIndex - относительный индекс оператора в хранилище, считается от 0
       *
       * Возвращает оператор по индексу или nil, если индекс неверен
       *
       *)
      Function GetOperator(iIndex: integer): TBaseOperator;
      
      (**
       * Возвращает количество операторов в скрипте.
       *
       *)
      Function GetCount: integer;

    Public
      
      (**
       * Конструктор скрипта.
       *
       * Параметры:
       *   oParent - родительский скрипт, можно и не указывать.
       *
       *)
      Constructor Create(oParent: TScript = nil);
      
      (**
       * Деструктор скрипта. Полностью очищает занимаимую скриптом и подчиненными объектами память.
       *
       *)
      Destructor Destroy; override;

      (**
       * Добавляет оператор в скрипт.
       *
       * Параметры:
       *   oOperator - оператор, который нужно добавить в скрипт.
       *
       *)
      Procedure Append(oOperator: TBaseOperator);
      
      (**
       * Убирает оператор из скрипта
       *
       * Параметры:
       *   oOperator - оператор, который нужно удалить из скрипта.
       *
       *)
      Procedure Remove(oOperator: TBaseOperator);
      
      (**
       * Убирает оператор из скрипта по его индексу
       *
       * Параметры:
       *   iIndex - индекс оператора для удаления.
       *
       *)
      Procedure Delete(iIndex: integer);

      (**
       * Удаляет все операторы из скрипта.
       *
       *)
      Procedure Clear;

      (**
       * По ссылке на оператор возвращает его порядковый индекс в хранилище
       *
       * Параметры:
       *   oOperator - оператор, для которого необходимо вернуть порядковый индекс.
       *
       *)
      Function IndexOf(oOperator: TBaseOperator): integer;

      (**
       * Метод выполнения скрипта.
       *
       *)
      Function Run: boolean;

      (**
       * Родительский скрипт.
       * Только для чтения.
       *
       *)
      Property Parent: TScript read FParent;

      (**
       * Позволяет получить ссылку на оператор по его порядковому индексу.
       * Только для чтения. Является свойством по умолчанию.
       *
       *)
      Property Operators[iIndex: integer]: TBaseOperator read GetOperator; default;

      (**
       * Количество операторов в хранилище.
       * Только для чтения.
       *
       *)
      Property Count: integer read GetCount;

      (**
       * Возвращаемое по окончании работы значение скрпта.
       * Обычно это результат оператора return для функции, в остальных
       * случаях свойство, как правило, обнулено.
       * Только для чтения.
       *
       *)
      Property RetValue: TVariableValue read FValue;

      (**
       * Тип возвращаемого значения.
       * Только для чтения.
       *
       *)
      Property RetType: TVariableType read FValueType;
  end;

  (**
   * Класс оператора типа "Константа". Помимо свойств базового оператора, класс наделен
   * всеми необходимыми свойствами константы, то есть значением и типом.
   *
   * Константа - это один из простейших операторов языка. Константу можно только объявить
   * с каким то определенным значением и далее это значение только читать.
   * Изменение значения константы во время выполнения скрипта недопустимо.
   * У константы точно так же есть оператор Run, этот оператор производит регистрацию
   * константы в общем списке констант и переменных скрипта.
   * Для инициализации константы, в классе описан метод Init, он должен быть вызван на стадии
   * сборки модели скрипта, когда будут определены тип и значение константы.
   *
   * В исходном коде этот оператор определен констукцией:
   *   const <Type> <Name> = <Value>;
   *
   *   const int iIntConstant = 256;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *
   * Ссылочные связи классов унаследованы от базового оператора.
   *
   *)
  TConstant = class(TBaseOperator)
    Protected

      (**
       * Значение данной константы
       *
       *)
      FValue: TVariableValue;

      (**
       * Тип значения
       *
       *)
      FValueType: TVariableType;

      (**
       * Позволяет установить значение FValue.
       * В данном классе этот метод является только заглушкой и лишь задает интерфейс
       * взаимодействия с полем FValue через свойство Value.
       *
       * Параметры:
       *   oValue - значение, которое необходимо записать в FValue
       *
       *)
      Procedure SetValue(oValue: TVariableValue); virtual;

      (**
       * Позволяет считать значение FValue
       *
       *)
      Function GetValue: TVariableValue; virtual;

    Public
      
      (**
       * Инициализация константы.
       *
       * Параметры:
       *   oValue - Значение, которое будет хранить константа
       *   eType  - Тип содержимого константы
       *
       *)
      Procedure Init(oValue: TVariableValue; eType: TVariableType);

      (**
       * Позволяет получить из оператора его строковое представление.
       *
       * Возвращает строку, символизирующую значение константы.
       *
       *)
      Function ToString: string; override;
      
      (**
       * Позволяет получить запись оператора в отладочном варианте.
       *
       * Возвращает строку, обоначающую значение константы в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Интерфейс запуска оператора.
       * Регистрирует константу в списке констант и переменных скрипта.
       *
       *)
      Procedure Run; override;

      (**
       * Возвращает тип значения константы.
       * Только для чтения.
       *
       *)
      Property Typecast: TVariableType read FValueType;

      (**
       * Возвращает значение константы.
       * Только для чтения.
       *
       *)
      Property Value: TVariableValue read GetValue write SetValue;
  end;

  (**
   * Класс оператора типа "Переменная", расширяет логику поведения константы.
   * Изменения заключаются лишь в том, что переменная позволяет изменять свое значение.
   * Тип так же задается только при инициализации и не может измениться во время выполнения скрпта.
   *
   * В исходном коде этот оператор определен констукцией (в квадратных скобках - необязательное):
   *   <Type> <Name>[ = <Value>];
   *
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TVariable
   *
   * Ссылочные связи классов унаследованы от базового оператора.
   *
   *)
  TVariable = class(TConstant)
    Protected
      
      (**
       * Позволяет установить значение FValue.
       * Реализует логику изменения значения переменной.
       *
       * Параметры:
       *   oValue - значение, которое необходимо записать в FValue
       *
       *)
      Procedure SetValue(oValue: TVariableValue); override;

  end;

  (**
   * Специальный класс строковой константы. Реализует логику хранения строк в скрипте.
   * В скрипте не допускается работа "напрямую" с константами или переменными типа "Строка",
   * строковые константы разрешается указывать только в операторе вывода (echo). Для такого
   * случая и разработан данный класс.
   *
   * Любя цифра или (в данном случае) строка - для скрипта это константа. Но такие константы не
   * должны регистрироваться при выполнении, это просто приведет к засорению соответствующего
   * спеиска скрипта. Если необходимо запретить выполняться какому либо оператору, необходимо
   * установить в его настройках значение ofNotActive.
   * Строковые константы уже создаются с этим флагом.
   *
   * Метод Init для данного класса принимает только строку, которой нужно инициализировать
   * константу, тип уже известен за рание - это тип строки (vtSTR)
   *
   * В исходном коде этот оператор определен констукцией:
   *   "<Value>"
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TSTRConstant
   *
   * Ссылочные связи классов унаследованы от базового оператора.
   *
   *)
  TSTRConstant = class(TConstant)
    Protected
      
      (**
       * Хранит знчение константы, теперь это уже строго строка.
       *
       *)
      FString: string;

      
      (**
       * Позволяет установить значение FString.
       * Метод так же ничего не выполняет, как и в классе TConstant, он лишь задает интерфейс
       * работы с полем FString через свойство Value.
       *
       * Параметры:
       *   sValue - Значение, которое необходимо записать в поле FString.
       *
       *)
      Procedure SetValue(sValue: string); virtual;
      
      (**
       * Возвращает значение поля FString.
       *
       *)
      Function GetValue: string; virtual;

    Public
      
      (**
       * Инициализация константы.
       *
       * Прараметры:
       *   sValue - значение, которым необходимо инициализировать константу.
       *
       *)
      Procedure Init(sValue: string);

      (**
       * Интерфейс запуска оператора.
       * Регистрирует константу в списке констант и переменных скрипта.
       *
       *)
      Procedure Run; override;
      
      (**
       * Позволяет получить из оператора его строковое представление.
       *
       * Возвращает строку, символизирующую значение константы.
       *
       *)
      Function ToString: string; override;

      (**
       * Позволяет получить запись оператора в отладочном варианте.
       *
       * Возвращает строку, обоначающую значение константы в отладочном виде.
       *
       *)
      Property Value: string read GetValue write SetValue;

  end;

  (**
   * Класс оператора типа "Функция". Функция является составным оператором, она позваляет выполнять
   * определенный блок операторов с передачей в него ряда параметров. Данный блок операторов
   * можно назвать подблоком или подпрограммой относительно основного скрипта, или просто
   * подскриптом. Фактически так и получается, функция имеет свой собственный объект-скрипт,
   * в котором и содержится набор тех самых операторов, а так же параметры функции в виде
   * переменных скрипта.
   *
   * Данный оператор выполняет роль декларации функции, его метод Run осуществляет регистрацию
   * функции в списке инициализированных функций основного скрипта, делая функцию доступной для
   * последующих вызовов. А метод Init - лишь устанавливает тип возвращаемого значения и
   * количество необходимых параметров функции.
   *
   * В исходном коде этот оператор определен констукцией (в квадратных скобках - необязательное):
   *   [const ]<Type> <FunctionName>( [<Type> <ParamName>[, <Type> <ParamName>]* ]* ){ <Operators> };
   *
   *   int MyFunction(){  };
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TFunction
   *
   * Ссылочные связи классов:
   *   TFunction
   *    +- TScript (1:1)
   *
   *)
  TFunction = class(TConstant)
    Protected
      
      (**
       * Подпрограмма, подскрипт тела функции.
       *
       *)
      FAction: TScript;
      
      (**
       * Число необходимых параметров, которые нужно передать функции перед ее вызовом.
       *
       *)
      FPrmCount: integer;

    Public
      
      (**
       * Конструктор функцци.
       * Помимо основных операций родительских классов, конструктор
       * создает тело функции - подскрипт.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор функции.
       * Необходим для очистки памяи тела функции.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Отладочная информация функции.
       *
       *)
      Function DBGString: string; override;
      
      (**
       * Интерфейс запуска оператора.
       * Регистрирует функцию в списке функций родительского скрипта.
       *
       *)
      Procedure Run; override;
      
      (**
       * Инициализация функции.
       *
       * Параметры:
       *   iPrmCount - Количество необходимых для запуска параметров.
       *   eType     - Тип возвращаемого функцией значения.
       *
       *)
      Procedure Init(iParamCount: integer; eType: TVariableType);
      
      (**
       * Исполнение подпрограммы функции.
       *
       *)
      Procedure Execute;
      
      (**
       * Позволяет получить тело функции.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;
      
      (**
       * Позволяет получить количество необходимых параметров.
       * Только для чтения.
       *
       *)
      Property ParamCount: integer read FPrmCount;
  end;

  (**
   * Класс оператора типа "Подпрограмма". Реализует логику простого подблока операторов.
   * Операторы, сгруппированные между символами { и } можно считать подблоком операторов.
   * Данный подблок выполняется как один оператор в рамках скрипта, при этом подблок является
   * подпрограммой и имет собственный скрипт, который и выполняет во время своего запуска.
   *
   * Метод Run для данного класса просто запускает его подпрограмму. А метод Init фиктивен
   * и присутствует только для обеспечения возможного расширения логики оператора.
   *
   * В исходном коде этот оператор определен констукцией:
   *   { <Operators> };
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TSubscript
   *
   * Ссылочные связи классов:
   *   TSubscript
   *    +- TScript (1:1)
   *
   *)
  TSubScript = class(TConstant)
    Protected
      
      (**
       * Подпрограмма, которую следует выполнить в операторе.
       *
       *)
      FAction: TScript;

    Public
      
      (**
       * Конструктор подблока.
       * Помимо основных действий создает объект скрипта для подпрограммы.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор подблока.
       * Необходим для очистки памяти, занимаемой подпрограммой.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Выдает содержимое оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Интерфейс запуска оператора.
       * Выполняет скрипт подпрограммы.
       *
       *)
      Procedure Run; override;
      
      (**
       * Инициализация оператора.
       * Практически никаких действий не выполняет.
       *
       *)
      Procedure Init;

      (**
       * Позволяет получить ссылку на скрипт подпрограммы.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;

  end;

  (**
   * Класс оператора типа "Вызов функции"
   * Описание функции - это один оператор и он выполняет одну функцию - определение
   * и регистрацию функции в списках, чтоб она была доступна для вызова.
   * Вызов функции - это исполнение кода функции с конкретно заданными параметрами,
   * это совсем отдельная от описания функции операция и это совершенно отдельный
   * оператор.
   *
   * Вызов функции осуществляется непосредственно с параметрами, метод Run выполняет
   * передачу параметров в функцию и вызывает у функции метод Execute. Метод Init служит
   * для опеределния функции, которую нужно вызвать.  
   *
   * В исходном коде этот оператор определен констукцией:
   *   <FunctionName>( [<Param>[, <Param>]* ]* );
   *
   *   MyFunc(op1, op2);
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TFunctionCall
   *
   * Ссылочные связи классов:
   *   TFunctionCall
   *    +- TFunction (1:1)
   *    +- TVarList  (1:1)
   *
   *)
  TFunctionCall = class(TConstant)
    Protected
      
      (**
       * Функция, вызов которой должен быть выполнен.
       *
       *)
      FFunction: TFunction;
      
      (**
       * Список операторов, которые будут выступать в качестве параметров функции при вызове.
       *
       *)
      FParams: TVarList;

    Public

      (**
       * Конструктор вызова функции.
       * Помимо основных действий создает объект списка параметров.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);

      (**
       * Деструктор Вызова функции.
       * Необходим для удаления содержимого и списка параметров.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Выводит дополнительную информацию о вызове.
       *
       *)
      Function DBGString: string; override;

      (**
       * Интерфейс запуска оператора.
       * Устанавливает значения параметров функции и вызывает метод Execute у функции.
       *
       *)
      Procedure Run; override;
      
      (**
       * Инициализация вызова фунцкии.
       * Устанавливает функцию, которая должна быть выполнена.
       *
       * Параметры:
       *   oFunction - ссылка на объявление функции, которую нужно вызвать.
       *
       *)
      Procedure Init(oFunction: TFunction);

      (**
       * Позволяет считать ссылку на описание вызываемой функции.
       * Только для чтения.
       *
       *)
      Property Func: TFunction read FFunction;
      
      (**
       * Позволяет считать список параметров, с которыми будет вызвана функция.
       *
       *)
      Property Params: TVarList read FParams;
  end;

  (**
   * Класс для базового типа "Операция". Операции в языке могут быть бинарными или унарными.
   * Бинарная операция для своей работы требует два оператора, взаимодействие между которыми и
   * осуществляет.
   * Унарная операция для своей работы требует только один оператор, преобразование
   * которого и осуществляет.
   * Все эти операции лучше всего объединить одним родительским классом - универсальной операцией,
   * которая не имеет логики всоего выполнения, но предоставляет общие характеристики для всех
   * осмысленных операций языка.
   * Функцию универсальной операции и выполняет данный класс.
   *
   * Метод Run в классе фиктивен, он изолирует логику исполнения оператора константы
   * от логики операций. Метод Init служит для определения обоих необходимых операторов.
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *
   * Ссылочные связи классов:
   *   TFunctionCall
   *    +- TConstant (1:1)
   *
   *)
  TOperation = class(TConstant)
    Protected

      (**
       * Ссылка на левый оператор выражения.
       *
       *)
      FLeftOp: TConstant;
      
      (**
       * Ссылка на правый оператор выражения.
       *
       *)
      FRightOp: TConstant;

    Public
      
      (**
       * Инициализация операции.
       * Устанавливает левый и правый операнды выражения.
       *
       * Параметры:
       *   oLeft  - Левый операнд
       *   oRight - Правый операнд
       *
       *)
      Procedure Init(oLeft, oRight: TConstant);
      
      (**
       * Возвращает значение операции в отладочном виде.
       *
       *)
      Function DBGString: string; override;
      
      (**
       * Интерфейс запуска операции.
       * В данном случае метод фиктивен.
       *
       *)
      Procedure Run; override;

  end;

  (**
   * Реализация оператора "Если-тогда-иначе", условного оператора другими словами.
   * Формально, условный оператор выполняет логику своей подпрограммы только тогда, когда
   * его условие возвращает истинный результат. Дополнительно условный оператор может иметь
   * вторую подпрограмму, логика которой может быть выполнена только если условие оператора
   * возвращает ложный результат.
   * Таким образом, если условие истинно, то выполняется основная подпрограмма оператора,
   * а если условие ложно, то выполняется альтернативная подпрограмма, если она определена.
   *
   * Метод Run реализует логику оператора, вызывая одну из подпрограмм в зависимости от
   * возвращаемого условием значения. Метод Init устанавливает выражение, которое следует
   * использовать как условие.
   *
   * В исходном коде этот оператор определен констукцией:
   *   if(<Expression>){ <Operators> }[esle{ <Operators> }];
   *
   *   if(10 > 5){  };
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionIF
   *
   * Ссылочные связи классов:
   *   TFunctionCall
   *    +- TConstant (1:1)
   *    +- TScript   (1:1)
   *
   *)
  TExpressionIF = class(TConstant)
    Protected
      
      (**
       * Ссылка на условие оператора.
       *
       *)
      FCondition: TConstant;
      
      (**
       * Ссылка на подпрограмму, выполняющуюся если условие истинно.
       *
       *)
      FAction: TScript;
      
      (**
       * Ссылка на подпрограмму, выполняющуюся если условие ложно.
       *
       *)
      FAltAction: TScript;

    Public
      
      (**
       * Конструктор оператора.
       * Дополнительно создает скрипты обеих подпрограмм.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Очищает занимаемую подпрограммами память.
       *
       *)
      Destructor Destroy; override;

      (**
       * Возвращает значение оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;
      
      (**
       * Инициализация оператора.
       * Определяет условие оператора.
       *
       *)
      Procedure Init(oCond: TConstant);
     
      (**
       * Интерфейс запуска оператора.
       * Сперва выполняет условие, затем смотрит на его значение, в зависимости
       * от которого выполняет ту или иную подпрограмму.
       *
       *)
       Procedure Run; override;
      
      (**
       * Позволяет получить ссылку на условие оператора.
       *
       *)
      Property Condition: TConstant read FCondition;
      
      (**
       * Позволяет получить ссылку на действие оператора.
       *
       *)
      Property Action: TScript read FAction;
      
      (**
       * Позволяет получить ссылку на альтернативное действие оператора.
       *
       *)
      Property AlterAction: TScript read FAltAction;
  end;

  (**
   * Реализация циклиеского оператора со счетчиком.
   * Цикл for - это счетчик с тремя базовыми операциями: инициализацией, условием выхода
   * и шагом счетчика.
   * Механика выполнения цикла выглядит так:
   *   1- Перед выполнением первого цикла выполняется операция инициализации счетчика.
   *   2- Перед запуском подпрограммы цикла выполняется операция проверки входа в цикл.
   *      Если операция проверки дает ложный результат, выполнение оператора завершается без
   *      выполнения подпрограммы икла. Если условие истинно, то выполняется подпрограмма.
   *   3- После каждого цикла выполняется операция сдвига счетчика и переход к следующему циклу.
   * Подпрограмма цикла является стандартным подблоком операторов, программно реализована все
   * тем же объектом скрипта.
   *
   * Метод Init оператора устанавливает все три базовые операции, а метод Run детально реализует
   * изложенный выше алгоритм.
   *
   * В исходном коде этот оператор определен констукцией:
   *   for(<Initial>; <Condition>; <RevolveAction>){<Operators>};
   *
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionFOR
   *
   * Ссылочные связи классов:
   *   TExpressionFOR
   *    +- TConstant (1:1)
   *    +- TScript   (1:1)
   *
   *)
  TExpressionFOR = class(TConstant)
    Protected
      
      (**
       * Ссылка на операцию инициализации цикла.
       * Во время выполнения выражение вызывается лишь единожды - до входа в самый первый цикл.
       *
       *)
      FInitialAction: TConstant;
      
      (**
       * Ссылка на выражение условия продолжения цикла.
       * Выполняется каждый раз перед исполнением подпрограммы цикла; служит условием,
       * в зависимости от которого выполняется подпрограмма или происходит завершение оператора.
       * Является первой стадией выполнения цикла оператора. Вторая стадия - выполнение
       * подпрограммы.
       *
       *)
      FStepCondition: TConstant;

      (**
       * Ссылка на выражение, изменяющее состояние счетчика цикла.
       * Выражение выполняется только после завершения выполнения подпрограммы цикла.
       * Является третьей стадией выполнения цикла оператора, после которой завершается
       * текущий и начинается новый цикл.
       *
       *)
      FStepAction: TConstant;
      
      (**
       * Ссылка на подпрограмму цикла. Это тело цикла, вторая стадия выполнения цикла оператора.
       *
       *)
      FAction: TScript;

    Public
      
      (**
       * Конструктор оператора.
       * Помимо всего, создает объект подпрограммы цикла.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Необходим для освобождения занимаемой подпрограммой память.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Вывод содержимого оператора в отладочном варианте.
       *
       *)
      Function DBGString: string; override;
      
      (**
       * Инициализация оператора.
       * Определяет все три базовые операции цикла.
       *
       * Параметры:
       *   oInitial - ссылка на операцию инициализации цикла.
       *   oCond    - ссылка на условие выполнения цикла.
       *   oStep    - ссылка на операцию изменения счетчика.
       *
       *)
      Procedure Init(oInitial, oCond, oStep: TConstant);
      
      (**
       * Интерфейс выполнения оператора.
       * Детально реализует алгоритм выполнения цикла, описанный перед объявлением класса.
       *
       *)
      Procedure Run; override;
      
      (**
       * Позволяет полуыить ссылку на подпрограмму выполнения цикла.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;
      
      (**
       * Позволяет получить ссылку на операцию инициализации цикла.
       * Только для чтения.
       *
       *)
      Property InitialAction: TConstant read FInitialAction;
      
      (**
       * Позволяет  получить ссылку на операцию условия выполнения цикла.
       * Только для чтения.
       *
       *)
      Property StepCondition: TConstant read FStepCondition;
      
      (**
       * Позволяет получить ссылку на операцию изменения счетчика.
       * Только для чтения.
       *
       *)
      Property StepAction: TConstant read FStepAction;
  end;

  (**
   * Класс реализации оператора цикла с предусловием. Основой работы цикла является операция
   * условия выполнения. Подпрограмма такого цикла раз за разом будет выполняться, пока его
   * условие не вернет ложный результат, а когда это случится, оператор цикла завершит свою
   * работу.
   * Механизм выполнения оператора примерно таков:
   *   1- Перед выполнением подпрограммы цикла (даже при первом цикле) происходит выполнение
   *      его условия. Если значение словия истинно, оператор переходит к следующему пункту.
   *      Если условие имеет ложный результат, то оператор завершает свою работу.
   *   2- Выполнение подпрограммы цикла.
   *
   * Метод Init оператора определяет условие цикла. Метод Run - детально реализует
   * изложенную логику.
   *
   * В исходном коде этот оператор определен констукцией:
   *   while(<Condition>){<Operators>};
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionWHILE
   *
   * Ссылочные связи классов:
   *   TExpressionWHILE
   *    +- TConstant (1:1)
   *    +- TScript   (1:1)
   *
   *)
  TExpressionWHILE = class(TConstant)
    Protected
      
      (**
       * Ссылка на оператор условия.
       * Этот оператор выполняется всякий раз в начале цикла, от его значения зависит,
       * станет ли оператор выполнять подпрограмму цикл или же завершит свое выполнение.
       *
       *)
      FCondition: TConstant;
      
      (**
       * Ссылка на скрипт подпрограммы цикла.
       * Этот блок операторв является телом цикла.
       *
       *)
      FAction: TScript;

    Public
      
      (**
       * Конструктор опратора.
       * Дополнительно создает объект подпрограммы цикла.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Служит для очистки памяти, занимаемой скрипто подпрограммы.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Возвращает информацию оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Инициализатор оператора.
       * Устанавливает оператор условия.
       *
       * Параметры:
       *   oCond - оператор, который надо будет использовать в качестве условия.
       *
       *)
      Procedure Init(oCond: TConstant);

      (**
       * Интерфейс запуска оператора.
       * Детально реализует изложенную логику работы оператора.
       *
       *)
      Procedure Run; override;

      (**
       * Позволяет получить ссылку на оператор условия.
       * Толкьо для чтения.
       *
       *)
      Property Condition: TConstant read FCondition;

      (**
       * Позволяет получит ссылку на скрипт подпрограммы.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;
  end;

  (**
   * Класс реализации оператора цикла с постусловием. Основой работы цикла является операция
   * условия выполнения. Подпрограмма такого цикла раз за разом будет выполняться, пока его
   * условие не вернет ложный результат, а когда это случится, оператор цикла завершит свою
   * работу.
   * Механизм выполнения оператора примерно таков:
   *   1- Выполняется подпрограмма цикла.
   *   2- Выполняется оператор условия цикла. Если значение условия истинно, то оператор переходит
   *      к началу нового цикла, иначе - завершает свое выполнение.
   *
   * Метод Init оператора определяет условие цикла. Метод Run - детально реализует
   * изложенную логику.
   *
   * В исходном коде этот оператор определен констукцией:
   *   do{<Operators>}while(<Condition>);
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionDO
   *
   * Ссылочные связи классов:
   *   TExpressionDO
   *    +- TConstant (1:1)
   *    +- TScript   (1:1)
   *
   *)
  TExpressionDO = class(TConstant)
    Protected
      
      (**
       * Ссылка на оператор условия.
       * Этот оператор выполняется всякий раз в конце цикла, от его значения зависит,
       * станет ли оператор выполнять подпрограмму цикл или же завершит свое выполнение.
       *
       *)
      FCondition: TConstant;
      
      (**
       * Ссылка на скрипт подпрограммы цикла.
       * Этот блок операторв является телом цикла.
       *
       *)
      FAction: TScript;

    Public
      
      (**
       * Конструктор опратора.
       * Дополнительно создает объект подпрограммы цикла.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Служит для очистки памяти, занимаемой скрипто подпрограммы.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Возвращает информацию оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Инициализатор оператора.
       * Устанавливает оператор условия.
       *
       * Параметры:
       *   oCond - оператор, который надо будет использовать в качестве условия.
       *
       *)
      Procedure Init(oCond: TConstant);
      
      (**
       * Интерфейс запуска оператора.
       * Детально реализует изложенную логику работы оператора.
       *
       *)
      Procedure Run; override;

      (**
       * Позволяет получить ссылку на оператор условия.
       * Толкьо для чтения.
       *
       *)
      Property Condition: TConstant read FCondition;

      (**
       * Позволяет получит ссылку на скрипт подпрограммы.
       * Только для чтения.
       *
       *)
      Property Action: TScript read FAction;
  end;

  (**
   * Класс оператора завершения функции.
   * Любая фунцкия языка может быть остановлена в любой момент ее выполнения. Моментом остановки
   * функции служит ывполнение данного оператора. При вызове оператора так же можно определить
   * выражение, значение которого будет передано как значение выполнения функции.
   * После выполнения данного оператора никакой другой оператор в теле функции более не выполняется
   * и считается, что вызов функции завершен.
   * Оператор работает следующим образом:
   *   1- Первым делом, оператор останавливает выполнение родительского скрипта.
   *      Это делается сбросом флага FScript.FWorkOn в значение false.
   *   2- Далее, переходя по значению TScript.Parent пока не встретится скрипт вызываемой функции,
   *      оператор каждому из скриптов так же сбрасывает флаг FWorkOn, останавливая их выполнение.
   *   3- Затем оператор останавливает выполнение скрипта вызываемой функции.
   *   4- Вызывается выполнение оператора возвращаемого значения, если он был определен. Его
   *      значение передается как значение подпрограммы функции.
   *
   *                                           +--- true --------------------+
   *  Заголовок функции (параметры функции){ <-+  <------ stop ----+         |
   *    ... операторы разные                                     3 |         |
   *    оператор с подпрограммой{ <---------------------- stop ----+         |
   *      ... еще операторы                                    2:1 |         |
   *      оператор с подпрограммой{ <-------------------- stop ----+         |
   *        ... снова операторы                                  1 |         |
   *        return true; +- 1 -> --- остановка выполнения ---------+         |
   *      }              +- 4 -> -------------- передача параметра true -----+
   *    }
   *  }
   *
   * Метод Init оператора позволяет задать прототип функции, в которой он будет вызван, и выражение,
   * значение которого будет передано в качестве результата вызова функции.
   *
   * В исходном коде этот оператор определен констукцией:
   *   return[ <Expression>];
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionRET
   *
   * Ссылочные связи классов:
   *   TExpressionRET
   *    +- TFunction (1:1)
   *    +- TConstant (1:1)
   *
   *)
  TExpressionRET = class(TConstant)
    Protected
      
      (**
       * Ссылка на прототип функции, относительно которого будет работать оператор.
       *
       *)
      FFunction: TFunction;

      (**
       * Выражение, значение которого должно быть передано в качестве значения подпрограммы
       * функции при ее завершении.
       *
       *)
      FExpression: TConstant;

    Public
      
      (**
       * Инициялизация оператора.
       * Определяет прототип функции и возвращаемое выражение.
       *
       * Параметры:
       *   oFunc - Прототип функции, относительно которой должен работать оператор.
       *   oExpr - Выражение, значение которого следует использовать как результат выполнения функции
       *
       *)
      Procedure Init(oFunc: TFunction; oExpr: TConstant);
      
      (**
       * Интерфейс выполнения оператора.
       * Выполняет остановку функции и обеспечивает возврат ее значения.
       *
       *)
      Procedure Run; override;
      
      (**
       * Возвращает информацию оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Позволяет получить ссылку на функцию, относительно которой работает оператор
       * Только для чтения.
       *
       *)
      Property RetFunction: TFunction read FFunction;
      
      (**
       * Позволяет получить ссылку на возвращаемое выражение.
       * только для чтения.
       *
       *)
      Property RetExpression: TConstant read FExpression;
  end;

  (**
   * Класс оператора вывода. Единственный оператор, в котором допускается использование строковых
   * данных в виде констант. Оператор является языковой конструкцией с неопределенным числом
   * параметров. Параметры записываются в оператор подобно тому, как записывается вызов функции,
   * они перечисляются через запятую. Во время своего выполнения, оператор формирует значения
   * всех его параметров в единую строку, а затем направляет эту строку в поток вывода.
   *
   * Данный оператор пока не нуждается в инициализации, его метод Init фиктивен и служит только
   * как заглушка. Метод Run последовательно выполняет каждый из параметров, затем присоединяет
   * значение выполненного параметра к результирующей строке, а затем отправляет полученную строку
   * в поток вывода через специальную функцию Echo, описанную в нижней части модуля.
   *
   * В исходном коде этот оператор определен констукцией:
   *   echo(<Expression>, ...);
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TExpressionECHO
   *
   * Ссылочные связи классов:
   *   TExpressionECHO
   *    +- TVarList (1:1)
   *
   *)
  TExpressionECHO = class(TConstant)
    Protected

      (**
       * Ссылка на список параметров, операторов, значения которых необходимо вывести.
       *
       *)
      FParams: TVarList;

    Public
      
      (**
       * Конструктор оператора.
       * Дополнительно создает объект списка праметров.
       *
       *)
      Constructor Create(oScript: TScript; oName: TToken);
      
      (**
       * Деструктор оператора.
       * Необходим для очистки памяти, занимаемой списком параметров.
       *
       *)
      Destructor Destroy; override;
      
      (**
       * Возвращает информацию оператора в отладочном виде.
       *
       *)
      Function DBGString: string; override;

      (**
       * Интерфейс запуска оператора.
       * Реализует операцию вывода.
       *
       *)
      Procedure Run; override;

      (**
       * Инициализатор оператора.
       * На данный момент фиктивен.
       *
       *)
      Procedure Init;
      
      (**
       * Позволяет получить ссылку на список параметров оператора.
       *
       *)
      Property Params: TVarList read FParams;
  end;

  (**
   * Реализация бинарной операции присваивания.
   * Операция присваивания так же является выражением (Expression) и точно так же во время своего
   * выполнения определяет собственное значение и тип, тип определяется именно во время выполнения
   * операции. Эта особенность делает оператор присваивания рекурсивным и позволяет использовать его
   * как часть общего выражения!
   * В результате, оператор можно использовать в качестве условий, параметров, подоператоров для
   * других операторов языка.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Identifier> = <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationLET
   *
   *)
  TOperationLET = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Сперва выполняет правый операнд, а затем присваивает значению левого операнда
       * значение правого.
       * После этого определяет собственные тип и значение в соответствии с левым операндом.
       *
       * При выполнении оператора используется матрица присваиваний с преобразованием типов
       * CA_LETMATRIX, с помощью которой делается определение необходимой функции.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Реализация оператора сложения. Оператор просто выполняет левый и правый операнды, а затем
   * складывает их значения с учетом типа. Результат сложения записывается в значение оператора.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> + <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationADD
   *
   *)
  TOperationADD = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем складывает их значения.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора вычитания. Работает аналогично сложению, только выполняет операцию вычитания.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> - <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationSUB
   *
   *)
  TOperationSUB = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем вычитает их значения.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора перемножения, выполняется как и любой другой математический оператор.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> * <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationMUL
   *
   *)
  TOperationMUL = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем перемножает их значения.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора деления. Реализует логику целочисленного деления и деления вещественных чисел.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> / <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationDIV
   *
   *)
  TOperationDIV = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет операцию деления.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора целого остатка от деления.
   * Тип значения оператора определяется в соответствии с приоритетами типов:
   * от более значимого к менее - float -> int -> bool
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> % <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationMOD
   *
   *)
  TOperationMOD = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет операцию остатка от деления.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "И"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> & <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationAND
   *
   *)
  TOperationAND = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "ИЛИ"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> | <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationOR
   *
   *)
  TOperationOR = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "Исключающее ИЛИ"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> ^ <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationXOR
   *
   *)
  TOperationXOR = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "Больше", "Больше или равно"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> > <Expression>;
   *   <Expression> >= <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationABOVE
   *
   *)
  TOperationABOVE = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "Меньше", "Меньше или равно"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> < <Expression>;
   *   <Expression> <= <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationBELOW
   *
   *)
  TOperationBELOW = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс оператора логического выражения "Эквивалентно", "Не эквивалентно"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   <Expression> == <Expression>;
   *   <Expression> != <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationEQUAL
   *
   *)
  TOperationEQUAL = class(TOperation)
    Public

      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;

  (**
   * Класс унарного логического оператора "НЕ"
   * Тип значения оператора только как bool, операция является логической.
   *
   * В исходном коде этот оператор определен констукцией:
   *   ! <Expression>;
   *
   * Иерархия классов:
   *   TObject
   *    +- TBaseOperator
   *        +- TConstant
   *            +- TOperation
   *                +- TOperationNOT
   *
   *)
  TOperationNOT = class(TOperation)
    Public
      
      (**
       * Интерфейс запуска оператора.
       * Выполняет операнды, а затем выполняет сравнение их значений.
       *
       *)
      Procedure Run; override;
  end;


  (**
   * Вспомогательная структура для определения соответствия приоритета строковому значению
   * определенного оператора.(нужна в алгоритме обюратной польской записи)
   *
   *)
  TOperPriority = record
    // Строка, с помощью которой записывается оператор
    Name: string;
    // Условный приоритет, смысл приоритета определяется непосредственно в алгоритме
    Value: byte;
  end;

  (**
   * Тип события вывода на экран.
   * Необъектный вариант события.
   *
   *)
  TEchoEvent = Procedure (sEchoString: string);

  (**
   * Тип события вывода на экран.
   * Объектный вариант события.
   *
   *)
  TObjEchoEvent = Procedure (sEchoString: string) of object;

  (**
   * Возвращает условный приоритет оператора по его строковой записи
   *
   * Параметры:
   *   sOperator - строка, с помощью которой записывается оператор
   *)
  Function GetOperatorOrder(sOperator: string): integer;

  (**
   * Гененрирует вызов события вывода на экран.
   *
   *)
  Procedure Echo(sOut: string);

  (**
   * Гененрирует вызов события вывода ошибки.
   *
   *)
  Procedure ErrorReport(sOut: string);

const
  (**
   * Содержит количество элементов в массиве CA_OPERORDER
   *
   *)
  CI_OPORDERCOUNT: integer = 16;

  (**
   * Содержит записи соответствия символьных записей операторов с их условными приоритетами.
   *
   *)
  CA_OPERORDER: array [0..15] of TOperPriority = (
    (Name: '!';  Value: 200), (Name: '+';  Value:  10), (Name: '-';  Value:  10),
    (Name: '*';  Value:  50), (Name: '/';  Value:  50), (Name: '%';  Value:  50),
    (Name: '&';  Value: 100), (Name: '|';  Value: 100), (Name: '^';  Value: 100),
    (Name: '>';  Value: 100), (Name: '<';  Value: 100), (Name: '=='; Value: 100),
    (Name: '>='; Value: 100), (Name: '<='; Value: 100), (Name: '!='; Value: 100),
    (Name: '=';  Value:   5)
  );

var
  // необъектное событие вывода на экран
  pStdEcho: TEchoEvent = nil;
  // объектное событие вывода на экран
  pObjEcho: TObjEchoEvent = nil;
  // необъектное событие вывода ошибки
  pStdError: TEchoEvent = nil;
  // объектное событие вывода ошибки
  pObjError: TObjEchoEvent = nil;

implementation

uses Math;

Type
  (**
   *
   *
   *)
  TLetOperation = Procedure (var oLeft: TVariableValue; oRight: TVariableValue);

(**
 * Возвращает условный приоритет оператора по его строковой записи
 * необходим при работе с обратной польской записью
 *)
Function GetOperatorOrder(sOperator: string): integer;
var
  iWalker: integer;
begin
  iWalker := 0;
  Result := 0;
  while (iWalker < CI_OPORDERCOUNT) and (Result = 0) do begin
    if CA_OPERORDER[iWalker].Name = sOperator then Result := CA_OPERORDER[iWalker].Value;
    inc(iWalker);
  end;
end;

(**
  Гененрирует вызов события вывода на экран
 *  pStdEcho - необъектный делегат
 *  pObjEcho - объектный делегат
 * чтобы проверить заполнен делегат или нет, используется метод assigned
 *  данная процедура объединяет оба делегата , чтобы одной процедурой передать
 *  строки на выход
 *)
Procedure Echo(sOut: string);
begin
  if assigned(pStdEcho) then
  begin
    pStdEcho(sOut);
  end
  else
  if assigned(pObjEcho) then
  begin
    pObjEcho(sOut);
  end;
end;

(** Гененрирует вызов события вывода ошибки
 *   pStdError - необъектный делегат
 *   pObjError - объектный делегат
 *   В данной процедуре проверяется заполнены ли делегаты (метод assigned)
 *   и в зависимости от вида делегата вызывается тот или иной метод
 *   генерирующий ошибку  
 *)
Procedure ErrorReport(sOut: string); 
begin
  if assigned(pStdError) then
  begin
    pStdError(sOut);
  end
  else
  if assigned(pObjError) then
  begin
    pObjError(sOut);
  end;
end;

(**  Метод приведения типов   (из целого в целое)
 *  левый операнд - целое число (1)
 *  правый операнд - целое число (1)
 * Результатом будет целое число
 *)
Procedure LetInt2Int(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := oRight.iValue;
end;

(** Метод приведения типов   (из целого в вещественное)
 * правый операнд целое число (1)
 * левый операнд вещественное число (2)
 * в результате выполнения метода
 * будет 13.0
 *)
Procedure LetInt2Float(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.fValue := oRight.iValue;
end;

(**
 * Метод приведения типов (из целого в логический)
 * правый операнд - целое число (0)
 * левый операнд - логическое число (3)
 * Результатом приведения будет true, если целое число отлично от 0
 * и false, если целое число=0
 *)
Procedure LetInt2Bool(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := 0; //делается для обнуления переменной, содержащей целое число
  oLeft.bValue := oRight.iValue <> 0;
end;

(**
 * Метод приведения типов  (из вещественного в целое)
 * Правый операнд - вещественное число (1)
 * Левый операнд - целоые число (0)
 * Результатом приведения будет целая часть вещественного числа
 * Метод floor - осцществляет коругление в сторону меньшего
    12.8 - стало 12
    -11,4  - стало -12
 *)
Procedure LetFloat2Int(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := Floor(oRight.fValue);
end;

(**
 * Метод приведения типов (из вещественного в вещественный)
 * Правый операнд - вещественное число (fValue 1)
 * Левый операнд - вещественное число  (fValue 1)
 * Результатом будет вещественное число 
 *)
Procedure LetFloat2Float(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.fValue := oRight.fValue;
end;

(**
 *  Метод приведения типов  (из вещественного в логическое)
 * Правый операнд - вещественное число (fValue 1)
 * Левый операнд - логическое число (bValue 2)
 * Результатом приведения будет true   , если
 * число (обрезанноме метордом floor) не будет равно 0
 *)
Procedure LetFloat2Bool(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := 0;//делается для обнуления переменной, содержащей целое число
  oLeft.bValue := Floor(oRight.fValue) <> 0;
end;

(**
 * Метод приведения типов (из логического в целое)
 * Правый операнд - логическое число
 * Левый операнд - целое число
 * Результатом приведения будет 1 если логический операнд =true
 * и 0 если логический операнд равен false
 *
 *)
Procedure LetBool2Int(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := 0; //делается для обнуления переменной, содержащей целое число
  oLeft.bValue := oRight.bValue;
end;

(**
 * Метод приведения типов  (из логического в вещественный)
 * Правый операнд - логическое число (2)
 * Левый операнд - вещественное число (1)
 * Результатом приведения будет  1.0, если правый операнд =true
 * 0.0, если правый операнд =false
 *)
Procedure LetBool2Float(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.fValue := integer(oRight.bValue);
end;

(**
 * Метод приведения типов (из логического в логический)
 * Правый операнд - логический
 * Левый опернад - логический
 * Результатом будет true млм false
 *)
Procedure LetBool2Bool(var oLeft: TVariableValue; oRight: TVariableValue);
begin
  oLeft.iValue := 0; //делается для обнуления переменной, содержащей целое число
  oLeft.bValue := oRight.bValue;
end;

const
  (**
   *
   *
   *)
  CA_LETMATRIX: array [vtINT..vtBOOL, vtINT..vtBOOL] of TLetOperation = (
    (LetInt2Int,   LetInt2Float,   LetInt2Bool),
    (LetFloat2Int, LetFloat2Float, LetFloat2Bool),
    (LetBool2Int,  LetBool2Float,  LetBool2Bool)
  );

//--------------------------------------------------------------------------------------------------
//--- TBaseOperator class body ---------------------------------------------------------------------
(**
 * Конструктор оператора.
 * Создает сам оператор, определяет для него родительский скрипт и имя,
 * производит регистрацию данного оператора в родительском скрипте.
 *
 * Параметры:
 *   oScript - родительский скрипт для данного оператора.
 *   oName   - название для данного оператора.
 *)
Constructor TBaseOperator.Create(oScript: TScript; oName: TToken);
begin
  FScript := oScript;
  FScript.Append(Self);
  FName := oName;
  FError := esOK;
  FFlags := [];
end;

(**
 *  Деструктор оператора.
 *  Удаляет оператор из хранилища
 * вызывает родительсктий метод десктрутора - директива inherited
 *)
Destructor TBaseOperator.Destroy;
begin
  FScript.Remove(Self); //удаляет оператор из хранилища
  inherited Destroy;
end;

(**
 *  Метод запуска оператора (фиктивен)
 *
 *)
Procedure TBaseOperator.Run;
begin

end;

(**
* Позволяет получить из оператора его строковое представление.
*)
Function TBaseOperator.ToString: string;
begin
  Result := '';
end;

(**
 * Позволяет получить запись оператора в отладочном варианте.
 *
 * Возвращает строку, обоначающую значение оператора в отладочном виде
 *)
Function TBaseOperator.DBGString: string;
begin
  Result := '';
end;
//--------------------------------------------------------------------------------------------------
//--- TScript class body ---------------------------------------------------------------------------
(**
 *  Конструктор объекта класса скрипта.
 *
 *)
Constructor TScript.Create(oParent: TScript);
begin
  FParent := oParent;
  FOperators := TList.Create;
  FVariables := nil;
  FFunctions := nil;
end;

(**
 * Деструктор объекта класса крипта.
 * Очищает стек переменных и функций
 * Очишщает стек операторов 
 *)
Destructor TScript.Destroy;
begin
  if FVariables <> nil then FVariables.Free;
  if FFunctions <> nil then FFunctions.Free;
  Clear; //удаляет все операторы из скрипта
  FOperators.Free;
end;
 
(**
 * Полная очистка списка операторов
 *
 *)
Procedure TScript.Clear;
begin
  while FOperators.Count > 0 do TBaseOperator(FOperators.Items[0]).Free;
end;
   
(**
 * Добавляет оператор в скрипт.
 *
 * Параметры:
 *   oOperator - оператор, который нужно добавить в скрипт.
 *   метод IndexOf - По ссылке на оператор возвращает его порядковый индекс в хранилище
 *)
Procedure TScript.Append(oOperator: TBaseOperator);
begin
  if FOperators.IndexOf(oOperator) < 0 then FOperators.Add(oOperator);
end;
  
(**
 *  Удаляет оператор из хранилища
 *
 *)
Procedure TScript.Remove(oOperator: TBaseOperator);
begin
  FOperators.Remove(oOperator);
end;
  
(**
 * Удаление оператора из скрипта по его индексу
 *
 *)
Procedure TScript.Delete(iIndex: integer);
begin
  FOperators.Delete(iIndex);
end;
   
(**
 * По ссылке на оператор возвращает его порядковый индекс в хранилище
 *
 *)
Function TScript.IndexOf(oOperator: TBaseOperator): integer;
begin
  Result := FOperators.IndexOf(oOperator);
end;
   
(**
 *  Основной метод запуска интерпретатора.
 *
 *)
Function TScript.Run: boolean;
var
  iWalker: integer; //специальный бегунок
  oCurrentOp: TBaseOperator;//текущий оператор
  bCanRun: boolean;//переменная логического типа
begin
  Result := false;
  FVariables := TVarList.Create;//создание списка переменных
  FFunctions := TVarList.Create;//создание списка функций

  try
    iWalker := 0;
    FWorkOn := true;//установка флаша, для разрешения скрипта
    //до тех пор пока есть операторы в скрипте и флаг запуска скрипта открыт (true)
    while (iWalker < FOperators.Count) and FWorkOn do
    begin
      oCurrentOp := TBaseOperator(FOperators[iWalker]);//берем оператор
      bCanRun := true;
      if oCurrentOp <> nil then
      begin
      //если запуск оператора разрешен, то запускаем его
        bCanRun := bCanRun and not(ofTraceOff in oCurrentOp.Flags);
        bCanRun := bCanRun and not(ofNotActive in oCurrentOp.Flags);
        if bCanRun then oCurrentOp.Run;
      end;
      inc(iWalker);
    end;
    FWorkOn := false;//запрет дальнейшего запуска
    Result := true;
  except
    on oInterruption: Exception do
    begin
      ErrorReport('[Run time error generated while script work''s]');
      ErrorReport(oInterruption.Message);
      Result := false;
    end;
  end;
  {очистка списков}
  FVariables.Free;
  FFunctions.Free;
  FVariables := nil;
  FFunctions := nil;
end;
   
(**
 * Возвращает оператор из хранилища по его индексу
 *
 * Параметры:
 *   iIndex - относительный индекс оператора в хранилище, считается от 0
 *
 * Возвращает оператор по индексу или nil, если индекс неверен
 *)
Function TScript.GetOperator(iIndex: integer): TBaseOperator;
begin
  Result := nil;
  if iIndex < 0 then exit;
  if FOperators.Count > iIndex then Result := TBaseOperator(FOperators.Items[iIndex]);
end;
   
(**
 * Метод возвращает количество операторов
 *
 *)
Function TScript.GetCount: integer;
begin
  Result := FOperators.Count;
end;
//--------------------------------------------------------------------------------------------------
//--- TConstant class body -------------------------------------------------------------------------

(**
 *  Метод инициализации константы.
 *  FValue := oValue - устанавливает значение
 *  FValueType- тип контсанты
 *)
Procedure TConstant.Init(oValue: TVariableValue; eType: TVariableType);
begin
  FValue := oValue;
  FValueType := eType;
end;
   
(**
  * Интерфейс запуска оператора.
  * Регистрирует константу в списке констант и переменных скрипта.
 *)
Procedure TConstant.Run;
begin
  if (ofNotActive in FFlags) or (ofInitialized in FFlags) then exit;
  FScript.FVariables.Add(Self);       //добавление инициализированной конкретной константы
  FFlags := FFlags + [ofInitialized]; //запрет повторной инициализации данной константы
end;
    
(**
* Позволяет установить значение FValue.
* В данном классе этот метод является только заглушкой и лишь задает интерфейс
* взаимодействия с полем FValue через свойство Value.
*
* Параметры:
*   oValue - значение, которое необходимо записать в FValue
*)
Procedure TConstant.SetValue(oValue: TVariableValue);
begin

end;
      
(**
 * Позволяет считать значение FValue
 *
 *)
Function TConstant.GetValue: TVariableValue;
begin
  Result := FValue;
end;
    
(**
* Позволяет получить из оператора его строковое представление.
* Возвращает строку, символизирующую значение константы.
 *)
Function TConstant.ToString: string;
begin
  case FValueType of
    vtINT:   Result := Format('%d',[FValue.iValue]);
    vtFLOAT: Result := StringReplace(Format('%f',[FValue.fValue]),',','.',[rfReplaceAll]);
    vtBOOL:  if FValue.bValue = true then Result := 'true' else Result := 'false';
  end;
end;
    
(**
 *Позволяет получить запись оператора в отладочном варианте.
 * Возвращает строку, обоначающую значение константы в отладочном виде
 *)
Function TConstant.DBGString: string;
begin
  case FValueType of
    vtINT:   Result := Format('%d',[FValue.iValue]);
    vtFLOAT: Result := StringReplace(Format('%f',[FValue.fValue]),',','.',[rfReplaceAll]);
    vtBOOL:  if FValue.bValue = true then Result := 'true' else Result := 'false';
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TVariable class body -------------------------------------------------------------------------

(**
       * Позволяет установить значение FValue.
       * Реализует логику изменения значения переменной.
       *
       * Параметры:
       *   oValue - значение, которое необходимо записать в FValue
 *)
Procedure TVariable.SetValue(oValue: TVariableValue);
begin
  FValue := oValue;
end;
//--------------------------------------------------------------------------------------------------
//--- TSTRConstant class body ----------------------------------------------------------------------

(**
 * Метод инициалищации строковой константы
 * Со строковыми константами никакие операции не произволятся, они только идут на вывод
 * поэтому флаг  ofNotActive возводится
 *)
Procedure TSTRConstant.Init(sValue: string);
begin
  FString := sValue;
  FValueType := vtSTR;
  FFlags := FFlags + [ofNotActive];
end;

(**
 * Интерфейс запуска строкой константы
 *
 *)
Procedure TSTRConstant.Run;
begin
  if ofNotActive in FFlags then exit;
  FScript.FVariables.Add(Self);//добавление в основной скрипт программы строковой const
  FFlags := FFlags + [ofNotActive];
end;
     
(**
 * Позволяет получить из оператора его строковое представление.
 *
 * Возвращает строку, символизирующую значение константы.
 *)
Function TSTRConstant.ToString: string;
begin
  Result := FString;
end;
     
(**
* Позволяет получить запись оператора в отладочном варианте.
* Возвращает строку, обоначающую значение константы в отладочном виде
*)
Procedure TSTRConstant.SetValue(sValue: string);
begin

end;
     
(**
 * Позволяет считать значение FString
 *
 *)
Function TSTRConstant.GetValue: string;
begin
  Result := FString;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperation class body ------------------------------------------------------------------------

(**
 * Метод инициализации операции
 *
 *)
Procedure TOperation.Init(oLeft, oRight: TConstant);
begin
  FLeftOp := oLeft;
  FRightOp := oRight;
end;
     
(**
 *  Интерфейс запуска.
 *
 *)
Procedure TOperation.Run;
begin
  if ofNotActive in FFlags then exit;

end;
     
(**
 * Повзоялет получить отладочную информацию.
 * Метод нужен при возникновении ошибки
 *)
Function TOperation.DBGString: string;
begin
  Result := '(';
  if FLeftOp <> nil then Result := Result + FLeftOp.DBGString;
  Result := Result + ' ' + FName.Value + ' ';
  if FRightOp <> nil then Result := Result + FRightOp.DBGString;
  Result := Result + ')';
end;
//--------------------------------------------------------------------------------------------------
//--- TFunction class body -------------------------------------------------------------------------

(**
       * Конструктор функцци.
       * Помимо основных операций родительских классов, конструктор
       * создает тело функции - подскрипт.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
 *)
Constructor TFunction.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);
end;
    
(**
* Деструктор функции.
* Необходим для очистки памяи тела функции.
 *)
Destructor TFunction.Destroy;
begin
  FAction.Free;
  inherited Destroy;
end;
     
(**
 * Интерфейс запуска функции
 * В основном скрипте регистрирует функцию
 * Возводит флаг запрета о повторной инициализации
 *)
Procedure TFunction.Run;
begin
  if (ofNotActive in FFlags) or (ofInitialized in FFlags) then exit;
  FScript.FFunctions.Add(Self);
  FFlags := FFlags + [ofInitialized];
end;
      
(**
 * Метод исполнения подпрограммы
 *
 *)
Procedure TFunction.Execute;
begin
  FAction.Run;//запуск тела функции
  FValue := FAction.RetValue;//результат оператора return, если есть
  FValueType := FAction.RetType;//тип возвращаемого значения
end;
     
(**
       * Инициализация функции.
       *
       * Параметры:
       *   iPrmCount - Количество необходимых для запуска параметров.
       *   eType     - Тип возвращаемого функцией значения.
 *)
Procedure TFunction.Init(iParamCount: integer; eType: TVariableType);
begin
  FValue.iValue := 0;
  FValueType := eType;
  FPrmCount := iParamCount;
end;
    
(**
 * Отладочная информация о функции
 *
 *)
Function TFunction.DBGString: string;
begin
  Result := Fname.Value+'(){   } ';
end;
//--------------------------------------------------------------------------------------------------
//--- TSubScript class body ------------------------------------------------------------------------

(**
* Конструктор подблока.
* Помимо основных действий создает объект скрипта для подпрограммы.
*
* Параметры:
*   oScript - родительский скрипт для данного оператора.
*   oName   - название для данного оператора.
 *)
Constructor TSubScript.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);//подпрограмма, которую надо выполнить
  FFlags := [ofNoReturn];//функция не остнавливается по оператору return
end;
    
(**
 * Деструктор подблока функции.
 * Очищает подпрограмму.
 *)
Destructor TSubScript.Destroy;  
begin
  FAction.Free;
  inherited Destroy;
end;
    
(**
 * Интерфейс запуска подпрограммы
 *
 *)
Procedure TSubScript.Run;
begin
  if ofNotActive in FFlags then exit;

  FAction.Run;//запуск подблока функции
  FValue := FAction.RetValue;//знеачение возвращаемое return
  FValueType := FAction.RetType;//тип возвращаемого значения
end;
    
(**
 * Иетод инициализации подблока для заклушки
 *
 *)
Procedure TSubScript.Init;
begin

end;
    
(**
 *  Вы дает отладочную информацию о подблоке
 *
 *)
Function TSubScript.DBGString: string;
begin
  Result := '{ ... }';
end;
//--------------------------------------------------------------------------------------------------
//--- TFunctionCall class body ---------------------------------------------------------------------

(**
       * Конструктор вызова функции.
       * Помимо основных действий создает объект списка параметров.
       *
       * Параметры:
       *   oScript - родительский скрипт для данного оператора.
       *   oName   - название для данного оператора.
 *)
Constructor TFunctionCall.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FParams := TVarList.Create;//список параметров функции
end;
    
(**
 *  Деструктор вызова функции
 *
 *)
Destructor TFunctionCall.Destroy;
begin
  FParams.Clear;//очищает список параметров
  FParams.Free;//Освобождает память из под списка параметров
  inherited Destroy;//вызов родительского деструктора
end;
    
(**
 * Интерфейс запуска оператора.
 * Устанавливает значения параметров функции и вызывает метод Execute у функции.
*)
Procedure TFunctionCall.Run;
var
  iPrmWalker: integer;
  oLeft: TConstant;
  oRight: TConstant;
begin
  if ofNotActive in FFlags then exit;

  try
    iPrmWalker := 0;
    {цикл выполняется пока есть  параметры вызова функции}
    while iPrmWalker < FParams.Count do
    begin
      oLeft := TConstant(FFunction.Action[iPrmWalker]);
      oRight := FParams[iPrmWalker].Value;//параметр функции
      oRight.Run;//запуск параметра функции
      {приведение типов}
      CA_LETMATRIX[oRight.Typecast, oLeft.Typecast](oLeft.FValue, oRight.Value);
      inc(iPrmWalker);
    end;
    if iPrmWalker < FFunction.ParamCount then raise Exception.Create('Not enough actual parameters to call this one.');
    FFunction.Execute;//вызов подблока функции
    FValue := FFunction.Value;//возвращаемое значение
    FValueType := FFunction.Typecast;//типо возвращаемого значения
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error when calling '+FFunction.DBGString+
        ' ['+IntToStr(FName.Line)+' '+IntToStr(FName.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
     
(**
       * Инициализация вызова фунцкии.
       * Устанавливает функцию, которая должна быть выполнена.
       *
       * Параметры:
       *   oFunction - ссылка на объявление функции, которую нужно вызвать.
 *)
Procedure TFunctionCall.Init(oFunction: TFunction);
begin
  FFunction := oFunction;
end;
    
(**
 * Метод выдает отладочную информацию при вызове функции , в случае
 * возникновения ошибок
 *)
Function TFunctionCall.DBGString: string;
begin
  Result := FFunction.Name.Value+'(){   } ';
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionIF class body ---------------------------------------------------------------------

(**
 * Конструктор оператора.
 * Дополнительно создает скрипты обеих подпрограмм.
 *)
Constructor TExpressionIF.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);
  FAltAction := TScript.Create(oScript);
  FCondition := nil;
end;
   
(**
* Деструктор оператора.
* Очищает занимаемую подпрограммами память.
 *)
Destructor TExpressionIF.Destroy;
begin
  FAction.Free;
  FAltAction.Free;
  inherited Destroy;
end;
   
(**
 * Метод инициализации оператора "если-то-иначе"
 *
 *)
Procedure TExpressionIF.Init(oCond: TConstant);
begin
  FCondition := oCond; //условие оператора
  {скрипт не запускает метод Run у данного опреатора}
  FCondition.Flags := FCondition.Flags + [ofTraceOff];
  // ??????????????????????????????????????????????????
  FCondition.Flags := FCondition.Flags - [ofNotActive];
end;
   
(**
 * Интефрейс запуска оператора "если-то-иначе"
 *
 *)
Procedure TExpressionIF.Run;
begin
  if ofNotActive in FFlags then exit;

  FCondition.Run;//запуск условия
  if FCondition.Value.bValue then //если условре истина, то
  begin
    FAction.Run;//запуск подблока при истинном условии
    FValue := FAction.RetValue;//возвращаемое значение
    FValueType := FAction.RetType;//тип возвращаемого значения
  end
  else
  {если условие ложно, то идем на else}
  if FAltAction.Count > 0 then
  begin
    FAltAction.Run;//запуск оператора если условие ложно
    FValue := FAltAction.RetValue;//возвращаемое значение
    FValueType := FAltAction.RetType;//тип возвращаемого значения
  end;
end;
   
(**
 * Отладочная информация в случае оишбки оператора условия
 *
 *)
Function TExpressionIF.DBGString: string;
begin
  Result := 'if(' + FCondition.DBGString + '){  }';
  if FAltAction.Count > 0 then begin
    Result := Result + 'else{   }';
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionFOR class body --------------------------------------------------------------------

(**
       * Конструктор оператора.
       * Помимо всего, создает объект подпрограммы цикла.
 *)
Constructor TExpressionFOR.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);//перекрываем метод с помощью метода   inherited
  FAction := TScript.Create(oScript);
  FInitialAction := nil;//условие начала цикла обнуляем
  FStepCondition := nil;//условие продолжения цикла обнуляем
  FStepAction := nil;//условие увеличения шага обнуляем
end;
   
(**
*Деструктор метода
* Очищает занимаемую память
 *)
Destructor TExpressionFOR.Destroy;
begin
  FAction.Free;
  inherited Destroy;
end;
   
(**
       * Инициализация оператора.
       * Определяет все три базовые операции цикла.
       *
       * Параметры:
       *   oInitial - ссылка на операцию инициализации цикла.
       *   oCond    - ссылка на условие выполнения цикла.
       *   oStep    - ссылка на операцию изменения счетчика.
 *)
Procedure TExpressionFOR.Init(oInitial, oCond, oStep: TConstant);
begin
  //установка начала цикла
  FInitialAction := oInitial;
  //??????????????????????????????????
  FInitialAction.Flags := FInitialAction.Flags + [ofTraceOff];
  FInitialAction.Flags := FInitialAction.Flags - [ofNotActive];

  //установка услвоия выполнения цикла
  FStepCondition := oCond;
    //??????????????????????????????????
  FStepCondition.Flags := FStepCondition.Flags + [ofTraceOff];
  FStepCondition.Flags := FStepCondition.Flags - [ofNotActive];

  //установка изменения шага цикла
  FStepAction := oStep;
    //??????????????????????????????????
  FStepAction.Flags := FStepAction.Flags + [ofTraceOff];
  FStepAction.Flags := FStepAction.Flags - [ofNotActive];
end;
  
(**
 * Интерфейс заруска оператора
 *
 *)
Procedure TExpressionFOR.Run;
var
  bStepFlag: boolean;
begin
  if ofNotActive in FFlags then exit;
  //если инициализация цикла не пуста, то выполняем ее
  if FInitialAction <> nil then FInitialAction.Run;
  //если изменение шага не пусто, то выполняем его
  if FStepCondition <> nil then
  begin
    FStepCondition.Run;
    bStepFlag := FStepCondition.Value.bValue;
  end
  else bStepFlag := true;

  {до тех пор пока выполняется условие цикла}
  while bStepFlag do
  begin
    FAction.Run; //запуск тела цикла
    if FStepAction <> nil then FStepAction.Run;
    if FStepCondition <> nil then
    begin
      FStepCondition.Run;
      bStepFlag := FStepCondition.Value.bValue;
    end;
  end;
  FValue := FAction.RetValue; //возвращаемое значение
  FValueType := FAction.RetType;//тип возвращаемого значения
end;
   
(**
 * Отладочная информация
 *
 *)
Function TExpressionFOR.DBGString: string;
begin
  Result := 'for(';
  if FInitialAction <> nil then Result := Result + FInitialAction.DBGString;
  Result := Result + '; ';
  if FStepCondition <> nil then Result := Result + FStepCondition.DBGString;
  Result := Result + '; ';
  if FStepAction <> nil then Result := Result + FStepAction.DBGString;
  Result := Result + '){  }';
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionWHILE class body ------------------------------------------------------------------

(**
* Конструктор опратора.
* Дополнительно создает объект подпрограммы цикла.
 *)
Constructor TExpressionWHILE.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);
  FAction := TScript.Create(oScript);
  FCondition := nil;
end;
   
(**
 *Деструктор оператора.
 *Очищает всю занимаемую память
 *)
Destructor TExpressionWHILE.Destroy;
begin
  FAction.Free;
  inherited Destroy;
end;
   
(**
 *Метод инициализации оператора цикла с предусловием

 *)
Procedure TExpressionWHILE.Init(oCond: TConstant);
begin
  FCondition := oCond;//оператор условия
  //???????????????????????????????????????????????
  FCondition.Flags := FCondition.Flags + [ofTraceOff];
  FCondition.Flags := FCondition.Flags - [ofNotActive];
end;
   
(**
 * Интерфейс запуска оператора
 *
 *)
Procedure TExpressionWHILE.Run;
begin
  if ofNotActive in FFlags then exit;

  FCondition.Run;//запуск условия цикла
  while FCondition.Value.bValue do
  begin
    FAction.Run; //запуск подпрограммы цикла
    FCondition.Run;//запуск условия цикла
  end;
  FValue := FAction.RetValue;//возвращаемое значение
  FValueType := FAction.RetType;// тип возвращаемого значения
end;
    
(**
 *  Отладочная ифнормация в случае ошибки
 *
 *)
Function TExpressionWHILE.DBGString: string;
begin
  Result := 'while('+FCondition.DBGString+'){   } ';
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionDO class body ---------------------------------------------------------------------

(**
  * Конструктор опратора.
  * Дополнительно создает объект подпрограммы цикла.
 *)
Constructor TExpressionDO.Create(oScript: TScript; oName: TToken);
begin
  inherited Create(oScript, oName);//перекрытие родительского метода
  FAction := TScript.Create(oScript); //сощдание тела цикла
  FCondition := nil;//услвоие цикла
end;
   
(**
*Деструктор оператора.
 *)
Destructor TExpressionDO.Destroy;
begin
  FAction.Free;
  inherited Destroy;
end;
   
(**
 * Инициализация оператора цикла с постусловием
 *
 *)
Procedure TExpressionDO.Init(oCond: TConstant);
begin
  FCondition := oCond;//оператор условия
  //??????????????????????????????????????????????
  FCondition.Flags := FCondition.Flags + [ofTraceOff];
  FCondition.Flags := FCondition.Flags - [ofNotActive];
end;
   
(**
 * Метод интерфейса запуска оператора
 *
 *)
Procedure TExpressionDO.Run;
begin
  if ofNotActive in FFlags then exit;

  repeat
    FAction.Run;//запуск тела цикла
    FCondition.Run;//запуск опреатора условия цикла
  until not FCondition.Value.bValue;
  FValue := FAction.RetValue;//возращаемое значение
  FValueType := FAction.RetType;//тип возвращаемого значения
end;
   
(**
 * Отладочная ифнормация
 *
 *)
Function TExpressionDO.DBGString: string;
begin
  Result := 'do{ }while('+FCondition.DBGString+')';
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionRET class body --------------------------------------------------------------------

(**
*Инициялизация оператора.
* Определяет прототип функции и возвращаемое выражение.
*
* Параметры:
*   oFunc - Прототип функции, относительно которой должен работать оператор.
*   oExpr - Выражение, значение которого следует использовать как результат выполнения функции
 *)
Procedure TExpressionRET.Init(oFunc: TFunction; oExpr: TConstant);
begin
  FFunction := oFunc; //прототип функции, относительно которго оператор работает
  FExpression := oExpr;// выражение  - результат
  //?????????????????????????????????????????????????????
  FExpression.Flags := FExpression.Flags + [ofTraceOff];
  FExpression.Flags := FExpression.Flags - [ofNotActive];
end;
   
(**
 * Интерфейс выполнения оператора.
 * Выполняет остановку функции и обеспечивает возврат ее значения.
 *)
Procedure TExpressionRET.Run;
var
  oScript: TScript;
begin
  if ofNotActive in FFlags then exit;

  oScript := FScript;
  while oScript <> FFunction.Action do
  begin
    oScript.FWorkOn := false;//остановка выполнения
    oScript := oScript.Parent;//ссылка на родительский скрипт
  end;
  oScript.FWorkOn := false;
  FFunction.Action.FWorkOn := false;//остановка выполнения тела функции
  FExpression.Run;//запуск возвращаемого выражения
  FFunction.FAction.FValue := FExpression.Value;//возвращаемое значение
  FFunction.FAction.FValueType := FExpression.Typecast;//возвращаемый тип
end;
  
(**
 * Отладочная информация
 *
 *)
Function TExpressionRET.DBGString: string;
begin
  Result := 'return ' + FExpression.DBGString;
end;
//--------------------------------------------------------------------------------------------------
//--- TExpressionECHO class body -------------------------------------------------------------------

(**
       * Конструктор оператора.
       * Дополнительно создает объект списка праметров.
 *)
Constructor TExpressionECHO.Create(oScript: TScript; oName: TToken);  
begin
  inherited Create(oScript, oName);
  FParams := TVarList.Create;
end;
   
(**
 * Деструктор оператора.
 * Необходим для очистки памяти, занимаемой списком параметров.
 *)
Destructor TExpressionECHO.Destroy;
begin
  FParams.Clear;
  FParams.Free;
  inherited Destroy; //вызов родительского десктруктора
end;
   
(**
 * Интерфейс запуска оператора.
 *
 *)
Procedure TExpressionECHO.Run;
var
  iWalker: integer;
  sOutStr: string;
begin
  if ofNotActive in FFlags then exit;

  sOutStr := '';
  iWalker := 0;
  while iWalker < FParams.Count do
  begin
    FParams[iWalker].Value.Run;//запуск параметров выводимо строки
    sOutStr := sOutStr + FParams[iWalker].Value.ToString;//строка собирается конкатенацией
    inc(iWalker);
  end;
  Echo(sOutStr);//вызов "абстрагированного метода"
end;
  
(**
 *  Инициализация метода.
 *  Служит для заглушки
 *)
Procedure TExpressionECHO.Init;
begin

end; 
  
(**
 *
 *  Отладочная информация
 *)
Function TExpressionECHO.DBGString: string;
begin
  Result := 'echo()';
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationLET class body ---------------------------------------------------------------------

(**
       * Интерфейс запуска оператора.
       * Сперва выполняет правый операнд, а затем присваивает значению левого операнда
       * значение правого.
       * После этого определяет собственные тип и значение в соответствии с левым операндом.
       *
       * При выполнении оператора используется матрица присваиваний с преобразованием типов
       * CA_LETMATRIX, с помощью которой делается определение необходимой функции.
 *)
Procedure TOperationLET.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FRightOp.Run;//запуск правого операнда
    //приведение типов
    CA_LETMATRIX[FRightOp.Typecast, FLeftOp.Typecast](FLeftOp.FValue, FRightOp.Value);
    FValue := FLeftOp.FValue;//установка значения
    FValueType := FLeftOp.Typecast;//установка типа
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationADD class body ---------------------------------------------------------------------

(**
 * Интерфейс запуска оператора сложения
 *
 *)
Procedure TOperationADD.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;//запуск левого операнда
    FRightOp.Run;//запуск правого операнда
    case FLeftOp.Typecast of //возвращаем тип значения левого операнда
     //если это целое число
      vtINT:
      begin
        case FRightOp.Typecast of//возвращаем тип правого операнда
          //если целое число
          vtINT: begin
            FValueType := vtINT;//тип результата будет целым
            //просто суммируем два числа
            FValue.iValue := FLeftOp.Value.iValue + FRightOp.Value.iValue;
          end;
          //если правый операнд - вещественное число
          vtFLOAT: begin
            FValueType := vtFLOAT;//результатом будет вещественное число
            //суммируем два числа
            FValue.fValue := FLeftOp.Value.iValue + FRightOp.Value.fValue;
          end;
          //если правый операнд логический тип
          vtBOOL: begin
            FValueType := vtINT;//результатом будет целое число
            //просто суммируем два числа, правый операнд переводится в число
            FValue.iValue := FLeftOp.Value.iValue + integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //если левый операнд вещественное число
      vtFLOAT: begin
        FValueType := vtFLOAT;//результатом выполнения суммы будет вещественный тип
        case FRightOp.Typecast of//проверяем тип правого операнда
        //если правый операнд целое число
          vtINT: begin
          //просто суммируем два числа
            FValue.fValue := FLeftOp.Value.fValue + FRightOp.Value.iValue;
          end;
          //если правый операнд вещественное число
          vtFLOAT: begin
          //суммируем два вещественных числа
            FValue.fValue := FLeftOp.Value.fValue + FRightOp.Value.fValue;
          end;
          //если правый операнд - логический тип
          vtBOOL: begin
          //суммируем два числа, правый операнд приводим к счислу с помощью - Integer
            FValue.fValue := FLeftOp.Value.fValue + integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //если левый операнд логическое число
      vtBOOL: begin
        case FRightOp.Typecast of//проверяем тип правого операнда
        //если правый операнд целое число
          vtINT: begin
            FValueType := vtINT;//результатом будет целое число
            //суммируем два числа, предварительно правый операнд преобразовова к числу (integer)
            FValue.iValue := integer(FLeftOp.Value.bValue) + FRightOp.Value.iValue;
          end;
          //если правый операнд вещественное число
          vtFLOAT: begin
            FValueType := vtFLOAT;//результат будет вещественным
            //суммируем два числа, предварительно преобразовав правый операнд к целому числу
            FValue.fValue := integer(FLeftOp.Value.bValue) + FRightOp.Value.fValue;
          end;
          //если правый операнд логический
          vtBOOL: begin
            FValueType := vtINT;//тип результата сложения будет целый
            //суммируем оба операнда, преобразовав их в числа
            FValue.iValue := integer(FLeftOp.Value.bValue) + integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+Fname.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationSUB class body ---------------------------------------------------------------------

(**
 * Интерфейс запуска операции вычитания
 *
 *)
Procedure TOperationSUB.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;//запуск левого операнда
    FRightOp.Run;//запуск правого операнда
    case FLeftOp.Typecast of //возвращаем тип левого операнда
    //если левый операнд - целое число
      vtINT: begin
        case FRightOp.Typecast of//возвращаем тип правого операнда
        //если это целое число
          vtINT: begin
            FValueType := vtINT;//результатом будет целый тип
            //делаем вычитание операндов
            FValue.iValue := FLeftOp.Value.iValue - FRightOp.Value.iValue;
          end;
          //если правый операнд вещесвтенное число
          vtFLOAT: begin
            FValueType := vtFLOAT;//результат будет вещественным
            //делаем вычитание операндов
            FValue.fValue := FLeftOp.Value.iValue - FRightOp.Value.fValue;
          end;
          //если правый операнд логическое
          vtBOOL: begin
            FValueType := vtINT;//тип будет целым
            //вычитаем операнды, преобразовав правый к числу (Integer)
            FValue.iValue := FLeftOp.Value.iValue - integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //если левый операнд вещественно число
      vtFLOAT: begin
        FValueType := vtFLOAT;//результатом будет вещесвтенное число
        //(вне зависимости от типа правого операнда)
        case FRightOp.Typecast of//проверяем тип правого операнда
        //если это целое число
          vtINT: begin
          // вычитаем два числа 
            FValue.fValue := FLeftOp.Value.fValue - FRightOp.Value.iValue;
          end;
          //если правый операнд вещественное число
          vtFLOAT: begin
          //просто вычитаем два операнда
            FValue.fValue := FLeftOp.Value.fValue - FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            FValue.fValue := FLeftOp.Value.fValue - integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //если левый операнд - логическое число
      vtBOOL: begin
        case FRightOp.Typecast of//проверяем тип правого операнда
        //если правый операнд целое число
          vtINT: begin
            FValueType := vtINT;//тип результата будет целый
            //вычитаем оба операнда, предварительно  левый преобразовав в целое
            FValue.iValue := integer(FLeftOp.Value.bValue) - FRightOp.Value.iValue;
          end;
          //если правый орперанд - вещественное число
          vtFLOAT: begin
            FValueType := vtFLOAT;//тип числа вещесвтенный
            //вычитаем оба опернада, левый преобразовав в число
            FValue.fValue := integer(FLeftOp.Value.bValue) - FRightOp.Value.fValue;
          end;
          //если правый операнд - логическое
          vtBOOL: begin
            FValueType := vtINT;//тип результата целый
            //вычитаем оба операнда преобразовав правый (Integer)
            FValue.iValue := integer(FLeftOp.Value.bValue) - integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationMUL class body ---------------------------------------------------------------------

(**
 *   Интерфейс запуска операции умножения
 *
 *)
Procedure TOperationMUL.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;//запуск левого операнда
    FRightOp.Run;//запуск правого операнда
    case FLeftOp.Typecast of//тип левого операнда
    //если тип левого операнда - целое
      vtINT: begin
        case FRightOp.Typecast of//возвращаем тип правого операнда
        //если правый операнд целое
          vtINT: begin
            FValueType := vtINT;//результатом умножения будет целоый тип
            //просто умножаем оба операнда
            FValue.iValue := FLeftOp.Value.iValue * FRightOp.Value.iValue;
          end;
          //если правый операнд вещественный
          vtFLOAT: begin
            FValueType := vtFLOAT;//тип резульата будет вещесвтенный
            //умножаем оба операнда
            FValue.fValue := FLeftOp.Value.iValue * FRightOp.Value.fValue;
          end;
          //если правый операнд логический
          vtBOOL: begin
            FValueType := vtINT;//тип результата будет целый
            //усножаем оба операнда, прдеварительно преобразова правый к числу (integer)
            FValue.iValue := FLeftOp.Value.iValue * integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //если левый операнд будет вещесвтенный
      vtFLOAT: begin
        FValueType := vtFLOAT;//тип результата будет вещесвтенный вне зависимости от
        //типа правого опернада
        case FRightOp.Typecast of//проверяем тип правого операнда
        //если тип правого опернада целый
          vtINT: begin
          //просто умножаем оба операнда
            FValue.fValue := FLeftOp.Value.fValue * FRightOp.Value.iValue;
          end;
          //тип правого операнда вещесветнный
          vtFLOAT: begin
          //просто умножаем оба опернада
            FValue.fValue := FLeftOp.Value.fValue * FRightOp.Value.fValue;
          end;
          //тип правого операнда логический
          vtBOOL: begin
          // умножаем оба операнда, предварительно преобразорвав правый в число (integer)
            FValue.fValue := FLeftOp.Value.fValue * integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //тип левого операнда логический
      vtBOOL: begin
        case FRightOp.Typecast of//проверяем тип правого операнда
        //правый операнд -целый
          vtINT: begin
            FValueType := vtINT;//тип будет целый
            //умножаем оба операнда, преобразовав левый в число (integer)
            FValue.iValue := integer(FLeftOp.Value.bValue) * FRightOp.Value.iValue;
          end;
          //правый операнд вещественный
          vtFLOAT: begin
            FValueType := vtFLOAT;//тип результата вещесветныый
            //умнодаем оба операнда, преобразовав левый в число (integer)
            FValue.fValue := integer(FLeftOp.Value.bValue) * FRightOp.Value.fValue;
          end;
          //правый опеарнд - логический
          vtBOOL: begin
            FValueType := vtINT;//тип результата целый
            //усножаем оба операнда преобразовав левый к числу (integer)
            FValue.iValue := integer(FLeftOp.Value.bValue) * integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationDIV class body ---------------------------------------------------------------------

(**
 * Интрефейс запуска операции деления
 *
 *)
Procedure TOperationDIV.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;//запускаем левый операнд
    FRightOp.Run;//запускаем правый опеарнд
    case FLeftOp.Typecast of//проверяем тип левого опеарнда
    //левый опеарнд целое число
      vtINT: begin
        case FRightOp.Typecast of//проверяем тип правого операнда
        //правый операнд целый
          vtINT: begin
            FValueType := vtINT;//тип результата будет целвый
            //просто выполняем деление опернадов (целочисленное деление)
            FValue.iValue := FLeftOp.Value.iValue div FRightOp.Value.iValue;
          end;
          //правый опеарнд - вещесветнный
          vtFLOAT: begin
            FValueType := vtFLOAT;//тип результата вещественный
            //выполняем деление операндов
            FValue.fValue := FLeftOp.Value.iValue / FRightOp.Value.fValue;
          end;
          //правый опеарнд - логический
          vtBOOL: begin
            FValueType := vtINT;//тип результата - целый
            //выполняем целочисленное деление, правый опеарнд преобразуем к числу (Integer)
            FValue.iValue := FLeftOp.Value.iValue div integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //левый операнд вещесветнный
      vtFLOAT: begin
        FValueType := vtFLOAT;//тип результата вещественный, вне зависимости
        //от типа правого операнда
        case FRightOp.Typecast of//определяем тип правого операнда
        //правый операнд целое число
          vtINT: begin
          //выполняем деление
            FValue.fValue := FLeftOp.Value.fValue / FRightOp.Value.iValue;
          end;
          //правый операнд вещесвтенный
          vtFLOAT: begin
          //выполняем деление операндов
            FValue.fValue := FLeftOp.Value.fValue / FRightOp.Value.fValue;
          end;
          //правый операнд логический
          vtBOOL: begin
          //выполняем деление, преобразовав правый опеарнд к числу (integer)
            FValue.fValue := FLeftOp.Value.fValue / integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //левый опеарнд логический
      vtBOOL: begin
        case FRightOp.Typecast of//проверяем тип правого опернада
        //правый опеарнд - целый
          vtINT: begin
            FValueType := vtINT;//тип результата целый
            //выполянем целочисленное деление, преобразовав левый операнд к числу
            FValue.iValue := integer(FLeftOp.Value.bValue) div FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            FValueType := vtFLOAT;
            FValue.fValue := integer(FLeftOp.Value.bValue) / FRightOp.Value.fValue;
          end;
          //правый операнд логический
          vtBOOL: begin
            FValueType := vtINT;//тип результата целый
            //выполняем цеочисленное деление, рпеобразовав оба опернда (integer)
            FValue.iValue := integer(FLeftOp.Value.bValue) div integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationMOD class body ---------------------------------------------------------------------

(**
 *  Интерефейс реализации операции "остаток от деления"
 *
 *)
Procedure TOperationMOD.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;//запуск левого операнда
    FRightOp.Run;//запуск правого операнда
    FValueType := vtINT;//тип результата целый
    //если оба операнда вещесвтенные, то это ошибка!
    if (FLeftOp.Typecast = vtFlOAT) or (FRightOp.Typecast = vtFLOAT) then begin
      raise Exception.Create('"Remainder" operation can''t be applied with float values');
    end;
    case FLeftOp.Typecast of//опеределяем тип левого операнда
    //левый операнд целый
      vtINT: begin
        case FRightOp.Typecast of//опередляем тип правого опернда
        //правый операнд - целый
          vtINT: begin
          //реализуем операцию остаток от деления
            FValue.iValue := FLeftOp.Value.iValue mod FRightOp.Value.iValue;
          end;
          //левый операнд - логический
          vtBOOL: begin
          //реализуем остаток от деления, правый опеарнд преобразовав в число (Integer)
            FValue.iValue := FLeftOp.Value.iValue mod integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //левый опеарнд логическое
      vtBOOL: begin
      //результат будет 0
        FValue.iValue := 0;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationAND class body ---------------------------------------------------------------------

(**
 * Интерфейс запуска операции "And", логическое умножение
 *
 *)
Procedure TOperationAND.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;//интерфейс запуска левого операнда
    FRightOp.Run;//интерфейс запуска правого операнда
    FValueType := vtBOOL;//тип результата будет логический
    //выполняем логическое умножение
    FValue.bValue := FLeftOp.Value.bValue and FRightOp.Value.bValue;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationOR class body ----------------------------------------------------------------------

(**
 *  Интерфейс запуска операции "ОR", логическое сложение
 *
 *)
Procedure TOperationOR.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;//интерфейс запуска левого опернада
    FRightOp.Run;//интерфейс запуска правого операнда
    FValueType := vtBOOL;//тип результата логический
    //реализация опеарции над опеарндами
    FValue.bValue := FLeftOp.Value.bValue or FRightOp.Value.bValue;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationNOT class body ---------------------------------------------------------------------

(**
 * Интерфейс запуска операции "Not", логическое отрицание
 *
 *)
Procedure TOperationNOT.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;//Интерфейс запуска левого операнда
    FValueType := vtBOOL;//результатом опеарции будет логический
    //реализация логической операции "not"
    FValue.bValue := not FLeftOp.Value.bValue;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationXOR class body ---------------------------------------------------------------------

(**
 * Интерфейс запуска опеарции "Исключающее ИЛИ"
   X1 X2  Y
   0  0   0
   0  1   1
   1  0   1
   1  1   0
 *
 *)
Procedure TOperationXOR.Run;
begin
  if ofNotActive in FFlags then exit;

  try
    FLeftOp.Run;//интерфейс запуска левого операнда
    FRightOp.Run;//интерфейс запуска правого операнда
    FValueType := vtBOOL; //тип результа алогичкский
    //реалищация операции "XOR"
    FValue.bValue := FLeftOp.Value.bValue xor FRightOp.Value.bValue;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationABOVE class body -------------------------------------------------------------------

(**
 * Интерфейс запуска опеартора больша иди равно
 *
 *)
Procedure TOperationABOVE.Run;
var
  bTestEqual: boolean;
begin
  if ofNotActive in FFlags then exit;

  try
    bTestEqual := FName.Value = '>=';//устанавливаем вид опеарции сравнения (> или >=)
    FLeftOp.Run;//интерефейс запуска левого операнда
    FRightOp.Run;//интерфейс запуска правого операнда
    FValueType := vtBOOL;//тип результата логический вне зависимости от типов операндов
    FValue.iValue := 0;
    case FLeftOp.Typecast of//опеределяем тип левого операнда
    //левый операнд целый
      vtINT: begin
        case FRightOp.Typecast of//оперелдяем тип правого операнда
        //правый опеарнд - целый
          vtINT: begin
          // реализация опеарции сравнения
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue >= FRightOp.Value.iValue
            else FValue.bValue := FLeftOp.Value.iValue > FRightOp.Value.iValue;
          end;
          //правый опеарнд - вещественный
          vtFLOAT: begin
          //реализация операции сравнения, правый опеарнд округляем (floor в сторону меньшего)
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue >= Floor(FRightOp.Value.fValue)
            else FValue.bValue := FLeftOp.Value.iValue > Floor(FRightOp.Value.fValue);
          end;
          //правый опеарнд - логический
          vtBOOL: begin
          //реализация операции сравнения, правый опеарнд преобразуется в число (integer)
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue >= integer(FRightOp.Value.bValue)
            else FValue.bValue := FLeftOp.Value.iValue > integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //левый опеарнд вещесветнный
      vtFLOAT: begin
        case FRightOp.Typecast of//опеределяем тип правого операнда
        //правый орперанд - целое
          vtINT: begin
          //реализация операции сравнения, левый опеарнд округляется (floor)
            if bTestEqual then FValue.bValue := Floor(FLeftOp.Value.fValue) >= FRightOp.Value.iValue
            else FValue.bValue := Floor(FLeftOp.Value.fValue) > FRightOp.Value.iValue;
          end;
          // правый опеарнд - вещесвтенный
          vtFLOAT: begin
          //реализация сравнения опеарндов
            if bTestEqual then FValue.bValue := FLeftOp.Value.fValue >= FRightOp.Value.fValue
            else FValue.bValue := FLeftOp.Value.fValue > FRightOp.Value.fValue;
          end;
          //правый опеарнд - логический 
          vtBOOL: begin
          //реализация сравнения, левый опеарнд округляется (floor)
            if bTestEqual then FValue.bValue := Floor(FLeftOp.Value.fValue) >= integer(FRightOp.Value.bValue)
            else FValue.bValue := Floor(FLeftOp.Value.fValue) > integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //левый опеарнд логический
      vtBOOL: begin
        case FRightOp.Typecast of//определяем тип правого операнда
        //правый опеарнд целое число
          vtINT: begin
          //реалищация сравнения, левый опеарнд преобразуется к числоу (integer)
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) >= FRightOp.Value.iValue
            else FValue.bValue := integer(FLeftOp.Value.bValue) > FRightOp.Value.iValue;
          end;
          //правый опеарнд вещественный
          vtFLOAT: begin
          //реализация сравнения, левый опеарнд приводится к числу (integer)
          //правый операнд округялется до целого (floor)
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) >= Floor(FRightOp.Value.fValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) > Floor(FRightOp.Value.fValue);
          end;
          // правый опеарнд логический
          vtBOOL: begin
          //реалищация сравнения, оба операнда приводятся к числу (integer)
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) >= integer(FRightOp.Value.bValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) > integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationBELOW class body -------------------------------------------------------------------

(**
 *
 *
 *)
Procedure TOperationBELOW.Run;
var
  bTestEqual: boolean;
begin
  if ofNotActive in FFlags then exit;

  try
    bTestEqual := FName.Value = '<=';
    FLeftOp.Run;
    FRightOp.Run;
    FValueType := vtBOOL;
    FValue.iValue := 0;
    case FLeftOp.Typecast of
      vtINT: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue <= FRightOp.Value.iValue
            else FValue.bValue := FLeftOp.Value.iValue < FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue <= Floor(FRightOp.Value.fValue)
            else FValue.bValue := FLeftOp.Value.iValue < Floor(FRightOp.Value.fValue);
          end;
          vtBOOL: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.iValue <= integer(FRightOp.Value.bValue)
            else FValue.bValue := FLeftOp.Value.iValue < integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtFLOAT: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestEqual then FValue.bValue := Floor(FLeftOp.Value.fValue) <= FRightOp.Value.iValue
            else FValue.bValue := Floor(FLeftOp.Value.fValue) < FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestEqual then FValue.bValue := FLeftOp.Value.fValue <= FRightOp.Value.fValue
            else FValue.bValue := FLeftOp.Value.fValue < FRightOp.Value.fValue;
          end;
          vtBOOL: begin
            if bTestEqual then FValue.bValue := Floor(FLeftOp.Value.fValue) <= integer(FRightOp.Value.bValue)
            else FValue.bValue := Floor(FLeftOp.Value.fValue) < integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      vtBOOL: begin
        case FRightOp.Typecast of
          vtINT: begin
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) <= FRightOp.Value.iValue
            else FValue.bValue := integer(FLeftOp.Value.bValue) < FRightOp.Value.iValue;
          end;
          vtFLOAT: begin
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) <= Floor(FRightOp.Value.fValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) < Floor(FRightOp.Value.fValue);
          end;
          vtBOOL: begin
            if bTestEqual then FValue.bValue := integer(FLeftOp.Value.bValue) <= integer(FRightOp.Value.bValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) < integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TOperationEQUAL class body -------------------------------------------------------------------

(**
 *  Интерфейс запуска опеарции эквивалентности (==)
 *
 *)
Procedure TOperationEQUAL.Run;
var
  bTestRevert: boolean;
begin
  if ofNotActive in FFlags then exit;

  try
    bTestRevert := FName.Value = '!=';//установка вида операции (== или !=)
    FLeftOp.Run;//интерфейс запуска левого опернада
    FRightOp.Run;//интерфейс запуска правого операнда
    FValueType := vtBOOL; //тип результата логический  , вне зависимости от типа операндов
    FValue.iValue := 0;//обнулим флажок целовго числа
    case FLeftOp.Typecast of //определяем тип левого операнда
    //тип левого операнда целое
      vtINT: begin
        case FRightOp.Typecast of//определяем тип правого операнда
        //правый опеарнд целый
          vtINT: begin
          //реализация опеарции
            if bTestRevert then FValue.bValue := FLeftOp.Value.iValue <> FRightOp.Value.iValue
            else FValue.bValue := FLeftOp.Value.iValue = FRightOp.Value.iValue;
          end;
          //правый опеарнд вещественный
          vtFLOAT: begin
          //реализация опеарции, правый опеарнд округляется (floor)
            if bTestRevert then FValue.bValue := FLeftOp.Value.iValue <> Floor(FRightOp.Value.fValue)
            else FValue.bValue := FLeftOp.Value.iValue = Floor(FRightOp.Value.fValue);
          end;
          //правый операнд - kjubxtcrbq
          vtBOOL: begin
          //реализация опеарции, правый опеарнд приводится к числу (integer)
            if bTestRevert then FValue.bValue := FLeftOp.Value.iValue <> integer(FRightOp.Value.bValue)
            else FValue.bValue := FLeftOp.Value.iValue = integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //тип левого операнда - вещесветнный
      vtFLOAT: begin
        case FRightOp.Typecast of//опередляем тип правого операнда
        //правый опеарнд - целое
          vtINT: begin
          //реализация опеарции, левый опеарнд округляется (floor)
            if bTestRevert then FValue.bValue := Floor(FLeftOp.Value.fValue) <> FRightOp.Value.iValue
            else FValue.bValue := Floor(FLeftOp.Value.fValue) = FRightOp.Value.iValue;
          end;
          // тип правого операнда-  вещественный
          vtFLOAT: begin
          // реализация оперции сравнения
            if bTestRevert then FValue.bValue := FLeftOp.Value.fValue <> FRightOp.Value.fValue
            else FValue.bValue := FLeftOp.Value.fValue < FRightOp.Value.fValue;
          end;
          //тип правого операнда - логический
          vtBOOL: begin
          //реалищация операции, левый операнд округляется (floor)
          //правый опеарнд приводится к числу (integer)
            if bTestRevert then FValue.bValue := Floor(FLeftOp.Value.fValue) <> integer(FRightOp.Value.bValue)
            else FValue.bValue := Floor(FLeftOp.Value.fValue) = integer(FRightOp.Value.bValue);
          end;
        end;
      end;
      //тип левого операнда  - логический
      vtBOOL: begin
        case FRightOp.Typecast of//определяем тип правого операнда
        //правый операнд - целый
          vtINT: begin
          // реализация опеарции, левый опеарнд приводится к числу (integer)
            if bTestRevert then FValue.bValue := integer(FLeftOp.Value.bValue) <> FRightOp.Value.iValue
            else FValue.bValue := integer(FLeftOp.Value.bValue) = FRightOp.Value.iValue;
          end;
          //реализация операции, левый опеарнд приводится к числу (Integer)
          // правый опеарнд округляется (floor)
          vtFLOAT: begin
            if bTestRevert then FValue.bValue := integer(FLeftOp.Value.bValue) <> Floor(FRightOp.Value.fValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) = Floor(FRightOp.Value.fValue);
          end;
          //тип правого операнда логический
          vtBOOL: begin
          //реализация операции, оба операнда приводятся к числу (integer)
            if bTestRevert then FValue.bValue := integer(FLeftOp.Value.bValue) <> integer(FRightOp.Value.bValue)
            else FValue.bValue := integer(FLeftOp.Value.bValue) = integer(FRightOp.Value.bValue);
          end;
        end;
      end;
    end;
  except
    on eInterruption: Exception do begin
      raise Exception.Create(
        'RT Error ('+FLeftOp.DBGString+' '+FName.Value+' '+FRightOp.DBGString+')['+
        IntToStr(FLeftOp.Name.Line)+' '+IntToStr(FLeftOp.Name.Symbol)+
        '] : " '+eInterruption.Message+' ".'
      );
    end;
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TVarList class body --------------------------------------------------------------------------

(**
 *  Конструктор создания объекта класса переменных
 *
 *)
constructor TVarList.Create;  
begin
 //создание списка переменных
  FList := TList.Create;
end;
   
(**
 *
 *
 *)
Destructor TVarList.Destroy;     
begin
  //очистка ото всех переменных
  Clear;
  //осовобождение памяти
  FList.Free;
end;
  
(**
 * Метод полной очистки спсика
 *
 *)
Procedure TVarList.Clear;           
begin
  while FList.Count > 0 do TVarListItem(FList.Items[0]).Free;
end;
  
(**
 *
 *
 *)
Procedure TVarList.Add(oVar: TConstant);
begin
  TVarListItem.Create(Self, oVar);
end;
   
(**
 *
 *
 *)
Procedure TVarList.Remove(oVar: TConstant);
var
  oItem: TVarListItem;
begin
  oItem := FindVar(oVar.Name);
  if oItem <> nil then oItem.Free;
end;
  
(**
 *
 *
 *)
Function TVarList.FindVar(oName: TToken): TVarListItem;
var
  iWalk: integer;
begin
  iWalk := 0;
  Result := nil;
  while FList.Count > iWalk do begin
    if TVarListItem(FList.Items[iWalk]).Value.Name.Value = oName.Value then begin
      Result := TVarListItem(FList.Items[iWalk]);
      break;
    end;
    inc(iWalk);
  end;
end;
  
(**
       * Метод служит для регистрации элемента в хранилище.
       * Элемент сам вызывает этот метод в собственном конструкторе.
       *
       * Параметры:
       *   oVar - элемент списка, который необходимо зарегистрировать
 *)
Procedure TVarList.AddVar(oVar: TVarListItem);  
begin
  FList.Add(oVar);
end;
  
(**
       * Метод снимает регистрацию элемента в хранилище.
       * Вызывается в деструкторе элемента списка.
       *
       * Параметры:
       *   oVar - элемент списка, который нужно снять с регистрации
 *)
Procedure TVarList.RemVar(oVar: TVarListItem);
begin
  FList.Remove(oVar);
end;
 
(**
       * Возвращает элемент списка по его числовому индексу.
       *
       * Параметры:
       *   iIndex - индекс элемента в хранилище, самый первый элемент имеет индекс 0
       *
       * Возвращает ссылку на элемент списка или nil, если по данному индексу нет элемента
 *)
Function TVarList.GetVar(iIndex: integer): TVarListItem;
begin
  if (iIndex >= 0) and (FList.Count > iIndex) then Result := TVarListItem(FList.Items[iIndex])
  else Result := nil;
end;
   
(**
 * Возвращает количество элементов
 *
 *)
FUnction TVarList.GetCount: integer;
begin
  Result := FList.Count;
end;
//--------------------------------------------------------------------------------------------------
//--- TVarListItem ---------------------------------------------------------------------------------

(**
* Конструктор элемента списка.
* Устанавливает хозяина И оператор для нового элемента.
* Осуществляет регистрацию в хранилище хозяина.
*
* Параметры:
*   oParent - ссылка на список, в котором будет содержаться данный элемент.
*   oValue - оператор скрипта, для которого заводится данный элемент.
 *)
constructor TVarListItem.Create(oParent: TVarList; oValue: TConstant);
begin
  FParent := oParent;
  FParent.AddVar(Self);
  FValue := oValue;
end;
  
(**
    * Деструктор элемента.
    * Снимает элемент с регистрации в хранилище хозяина.
 *)
destructor TVarListItem.Destroy;
begin
  FParent.RemVar(Self);
  inherited Destroy;
end;
//--------------------------------------------------------------------------------------------------
end.
