unit processor;
(**
 * Модуль синтаксического анализатора и генератора кода. Основным классом модуля является
 * класс TCodeProcessor (условно - процессор). Процессор являет собой два взаимно интегрированных
 * механизма - синтаксический анализатор и генератор кода, реализации механизмов неразрывны друг
 * с другом.
 *
 * Синтаксический анализ реализован методом рекурсивного спуска с небольшой переработкой.
 * Вся переработка метода заключается в следующем. Обычная реализация механизма опирается на
 * взаимные рекурсивные вызовы методов раз заразом, пока код не будет разобран. При разборе
 * подблоков операторов, подпрограмм или очень сложных математических формул с большим числом
 * подблоков и вложений нагрузка на основной стек программы начинает нелинейно возрастать,
 * что рано или поздно, при разборе выражений определенной степени вложенности, приводит к
 * переполнению стека программы и завершению процесса в целом.
 *
 * Решить данную проблему можно сместив акцент алгоритма с основного стека программы на что то
 * другое, предоставляющее точно такие же возможности хранения данных. Более того, если детально
 * разобрать алгоритм разбора, выделить основные элементы требующие хранения в стеке, а затем
 * сравнить процент созданных этими элементами данных с общим процентом увеличения стека в рекурсии,
 * то на лицо будет очевиден чудовищный перерасход памяти!
 * Для корректной работы алгоритма в стековой форме хранить требуется всего немного состояний
 * и данных:
 *   - текущую разбираемую подпрограмму,
 *   - инициализированные в локальные и глобальные (то есть, определенные в подпрограмме и до нее)
 *     переменные,
 *   - инициализированные локальные и глобальные функции,
 *   - очередность вызовов функций для достижения разбираемого подблока.
 *
 * Самое основное - это стек разбираемых подблоков, благодаря этому стеку можно развернуть
 * рекурсию в цикл на стадии начала разбора подпрограммы. Вместо вызова осноного метода разбора
 * в этом случае будет достаточо только занести в соответствующий стек такое состояние, при
 * котором будет ясно, что с этого момента будет разбираться новый подблок операторов.
 * Но при этом необходимо условиться, что любой генерируемый код будет создаваться только для
 * того подблока операторов, который лежит в вершине этого стека на данное время.
 *
 * Коротко, что такое стек? Это структура хранения данных, наделенная строгим алгоритмом их обработки.
 * При добавлении элемента, ему назначается условный индекс нулевой позиции, а всем остальным
 * элементам стека данный индекс увеличивается. То есть, добавить элемент можно только в голову.
 * При запросе на удаление элемента, удалить возможно толкьо элемент с нулевым индексом, после
 * удалениия элемента, всем индексы всех оставшихся элементов уменьшаются. Другими словами,
 * Удалить элмент можно тоже только из головы.
 * Условно принято операцию добавления элемента в стек называть вставкой (Push), а операцию
 * удаления - выталкиванием (Pop).
 * Общепринятая абривиатура именования такого алгоритма хранения данных - LIFO (Last In - First Out)
 *
 * Любая программа интепретатора реализована объектом класса TScript, как основная программа,
 * так и любая подпрограмма основной программы или составного оператора. Этот момент очень полезен
 * при создании стека разбираемых подблоков.
 * Класс TScriptStack реализует именно такой стек. Объект класса сможет хранить ссылки на объекты
 * TScript в виде стека, обеспечивая необходимое отражение иерархии вложенности блоков подпрограмм.
 *
 * Сам по себе объект TScript (далее просто скрипт) не содержит списков зарегистрированных в нем
 * локальных функций и переменных, в принципе можно было бы для каждого попавшего в стек скрипта
 * заводить свои списки для этих целей, но это не рационально с точки зрения оперативности работы и
 * поиска необходимых данных. Ведь любая переменная или функция, зарегистрированная в глобальном
 * пространстве, может быть доступна в любом месте подпрограммы любой степени вложенности.
 * Поэтому разумнее будет оптимизировать работу стеков для переменных и функций, согласовать их
 * работу с состоянием стека скриптов так, чтобы при выталкивании скрипта из стека все локальные
 * для него переменные и функции так же выталкивались из соответствующих стеков.
 *
 * Классы TVarStack и TFuncStack сделаны так, что дополнительно позволяют содержать связь между
 * объектом TScript и целевым объектом хранения. Вызывая методы EnterScript и LeaveScript можно
 * с легкостью менять локальность переменных и быстро удалять более ненужные локальные данные.
 *
 *)
interface

uses
  Windows, Classes, SysUtils,
//--- Собственные модули ---------------------------------------------------------------------------
  tokenizer, operators, TextMessages,
//--------------------------------------------------------------------------------------------------
  Math;

Type
  // Предопределения классов...
  TVarStackItem = class;
  TFuncStackItem = class;

  (**
   * Класс стека скриптов.
   * Стек скриптов служит хорошим отражением иерархической структуры подпрограмм в программе.
   * Языковая конструкция вида:
   *   <Начало подпрограммы 1>
   *     <Оператор>
   *     ...
   *     <Начало подпрограммы 2>
   *       <Оператор>
   *       ...
   *       <Начало подпрограммы 3>
   *         ...                    <--- текущая позиция разбора ---
   *       <Конец подпрограммы 3>
   *       ...
   *     <Конец подпрограммы 2>
   *     ...
   *   <Конец подпрограммы 1>
   *
   * во время разбора подпрограммы 3, в стеке может быть представлена как:
   *   -+
   *    +[0]- Подпрограмма 3
   *    +[1]- Подпрограмма 2
   *    +[2]- Подпрограмма 1
   *    +[3]- Основная программа скрипта
   *
   * При разборе данный стек применяется следующим образом:
   *   - Когда встречается оператор начала подрограммы (символ "{"), производится создание нового
   *     объекта TScript с указанием в качестве родительского - головного скрипта в стеке.
   *     После этого происходит завершение цепочки вызовов и возврат в цикл основного метода разбора.
   *   - В дальнейшем разборе любой новый оператор создается только для головного скрипта в стеке.
   *   - Когда встречается оператор завершения подпрограммы (символ "}"), считается, что здесь
   *     происходит завершение разбора именно текущего головного скрипт стека. Поэтому скрипт просто
   *     выталкивается из стека, перемещая его родительский скрипт на место головного скрипта.
   * Таким образом обеспечивается соблюдение иерархической цельности разбираемых подпрограмм.
   * Что касается разбора основного пространства программы, во время разбора считается, что скрипт
   * основной программы уже назодится в стеке, таким образом первый же оператор будет записан именно
   * в скрипт основной программы, а первый же подскрипт будет связан с основной программой через
   * ссылку на родительский скрипт.
   *
   *)
  TScriptStack = class
    Private

      // Хранилище скриптов, содержит в себе ссылки на объекты TScript.
      FStack: TList;

      (**
       * Возвращает количество скриптов в стеке.
       *
       *)
      Function GetCount: integer;
      
      (**
       * Возвращает ссылку на скрипт по его условному индексу.
       *
       * Параметры:
       *   iIndex - Условный индекс скрипта, ссылку на который необходимо получить.
       *
       * Возвращает объект TScript, если все хорошо, или nil, если по индексу скрипт не найден. 
       *
       *)
      Function GetScript(iIndex: integer): TScript;

    Public
      
      (**
       * Конструктор стека.
       * Дополнительно создает хранилище скриптов.
       *
       *)
      Constructor Create;
      
      (**
       * Деструктор стека.
       * Необходим для очистки хранилища от ссылок и освобождения занимаемой им памяти.
       *
       *)
      Destructor Destroy; override;

      (**
       * Механизм стека, позволяющий вставить скрипт в стек.
       *
       * Параметры:
       *   oScript - ссылка на скрипт, который необходимо добавить в стек.
       *
       *)
      Procedure Push(oScript: TScript);
      
      (**
       * Механизм стека, позволяющий вытолкнуть скрипт из стека.
       *
       * Возвращает ссылку на вытолкнутый скрипт, или nil, если стек итак был пустым.
       *
       *)
      Function Pop: TScript;

      // Позволяет считать число скриптов в стеке.
      Property Count: integer read GetCount;

      // Позволят обращаться к скриптам в стеке по их условным индексам.
      Property Script[iIndex: integer]: TScript read GetScript; default;

  end;

  (**
   * Класс стека лексем. Один из самых необходимых, на ряду со стеком скриптов, стеков для разбора.
   * С помощью данного стека в методику разбора вносится элемент запоминания лексем. Все дело в
   * упрощении процесса разбора. Первой стадией упрощения стало превращение лексического анализатора
   * в итератор лексем, во время синтаксического разбора считается, что лексический анализатор уже
   * завершил первую стадию разбора и содержит набор лексем из исходного кода, а значит для
   * снтаксического анализа достаточно только изучить имеющиеся лексемы, для этого в лексическом
   * анализаторе предусмотрен механизм итератора лексем, именно как итератор он и используется во
   * время синтаксического анализа.
   * Но итарционный механизм накладывает существенное ограничение - перемещение возможно только на
   * следующую лексему, на предыдущую лексему перейти невозможно. Из за этого есть шанс потерять
   * нить вывода разбираемого в данное время выражения.
   * Именно за счет стека лексем и решается данная проблема. Стек позволяет запомнить только нужные
   * для разбора лексемы и без проблем смещать итератор далее.
   * Стек лексем полностью сохраняет принципы хранения и обработки данных (LIFO).
   *
   *)
  TTokenStack = class
    Private

      // Хранилище лексем, в нем будут содержаться ссылки на лексемы из токенайзера.
      FStack: TList;

      (**
       * Возвращает количество скриптов в стеке.
       *
       *)
      Function GetCount: integer;

      (**
       * Возвращает ссылку на лексему по ее условному интексу.
       *
       * Параметры:
       *   iIndex - Условный индекс, относительно которого необходимо получить лексему.
       *
       * Возвращает ссылку на лексему, если все хорошо, или nil, если по индексу не нашлось лексемы
       *
       *)
      Function GetToken(iIndex: integer): TToken;

    Public

      (**
       * Конструктор стека.
       * Дополнительно создает объект хранилища лексем.
       *
       *)
      Constructor Create;

      (**
       * Деструктор стека.
       * Необходим для очистки хранилища лексем и освобождения занимаемой им памяти.
       *
       *)
      Destructor Destroy; override;

      (**
       * Механизм стека, позволяющий вставить лексему в стек.
       *
       * Параметры:
       *   oToken - ссылка на лексему, которую необходимо добавить в стек.
       *
       *)
      Procedure Push(oToken: TToken);
      
      (**
       * Механизм стека, позволяющий вытолкнуть лексему из стека.
       *
       * Возвращает ссылку на вытолкнутую лексему, или nil, если стек итак был пустым.
       *
       *)
      Function Pop: TToken;

      // Позволяет считать число лексем в стеке.
      Property Count: integer read GetCount;

      // Позволят обращаться к лексемам в стеке по их условным индексам.
      Property Token[iIndex: integer]: TToken read GetToken; default;
  end;

  (**
   * Класс стека переменных. Профильный стек для хранения только тех переменных, которые были
   * инициализированы выше по коду.
   * Структура языка такова, что если в одном месте кода, в коакой то определенной подпрограмме
   * была инициализирована переменная или константа, то она будет доступна для любого последующего
   * оператора в любой подпрограмме данной подпрограммы, если ее имя не будет переопределено в
   * подпрограмме. А по завершении подпрограммы, все ее переменные удаляются и становятся
   * недоступными.
   *
   * Данный стек предусматривает и эту особенность. Стек содержит ссылку на текущий разбираемый
   * скрипт. Для большей гибкости использования стека, вместо прямой связи данного стека со стеком
   * скриптов используется интерфейс входа и выхода - методы EnterScript и LeaveScript.
   * Считается, что во время выполнения EnterScript синтаксический анализатор выполняет подготовку к
   * разбору очередной подпрограммы. Стек просто меняет ссылку на текущий локальный скрипт и считает
   * все имеющиеся в нем переменные глобальными по отношению к этому скрипту.
   *
   * Когда происходит инициализация новой константы или переменной, ее ссылка вставляется в данный
   * стек и связывается именно со ссылкой на текущий локальный скрипт.
   *
   * Во время вызова LeaveScript стек считает, что синтаксический анализатор завершает разбор
   * текущего локального скрипта, следовательно необходимо вытолкнуть все приписанные этому скрипту
   * ссылки, потому что они более не действительны. После того, как все ссылки для локального
   * скрипта будут вытолкнуты, локальным скриптом станет считаться скрипт, к которому будет
   * приписана головная ссылка в стеке (если такая есть, а если нет, то локальным скриптом
   * ставится скрипт основной программы). 
   *
   *)
  TVarStack = class
    Private

      // Хранилище ссылок на переменные и константы, тут будут содержаться ссылки на TVarStackItem
      FStack: TList;

      // Ссылка на текущий локальный скрипт
      FLocalScript: TScript;

      // Ссылка на основной скрипт программы
      FMainScript: TScript;

    Protected

      (**
       * Производит вставку элемента в стек.
       * Вызывается автоматически в конструкторе класса TVarStackItem.
       *
       * Параметры:
       *   oVar - ссылка на элемент, который надо вставить.
       *
       *)
      Procedure AddVar(oVar: TVarStackItem);
      
      (**
       * Производит выталкивание элемента из стека.
       * Вызывается автоматически в деструкторе класса TVarStackItem.
       *
       * Параметры:
       *   oVar - ссылка на элемент, который надо вытолкнуть.
       *
       *)
      Procedure RemVar(oVar: TVarStackItem);

      (**
       * Возвращает ссылку на элемент стека по его условному индексу.
       *
       * Параметры:
       *   iIndex - условный индекс, по которому нужно получит переменную или константу.
       *
       * Возвращает ссылку на элемент, если все в порядке, или nil, если по индексу не
       * нашлось элемента.
       *
       *)
      Function GetVar(iIndex: integer): TVarStackItem;
      
      (**
       * Возвращает количество ссылок в хранилище на данное время.
       *
       *)
      FUnction GetCount: integer;

    Public
      
      (**
       * Конструктор стека.
       * Дополнительно, создает объект хранилища ссылок.
       *
       *)
      constructor Create;
      
      (**
       * Деструктор стека.
       * Очищает стек и удаляет объект хранилища.
       *
       *)
      Destructor Destroy; override;

      (**
       * Полностью очищает стек.
       *
       *)
      Procedure Clear;
      
      (**
       * Интерфейс входа в скрипт.
       * Устанавливает новый локальный скрипт.
       *
       * Параметры:
       *   oScript - скрипт, который будет локальным
       *
       *)
      Procedure EnterScript(oScript: TScript);

      (**
       * Интерфейс выхода из скрипта.
       * Выталкивает все ссылки для локального скрипта и изменяет ссылку на сам локальный скрипт.
       *
       * Параметры:
       *   oScript - Ссылка на скрипт, относительно которого выполняется метод выхода.
       *             По умолчанию это текущий локальный скрипт.
       *
       *)
      Procedure LeaveScript(oScript: TScript = nil);

      (**
       * Метод вставки элемента.
       * Производит вставку переменной для текущего локального скрипта.
       *
       * Параметру:
       *   oVar - ссылка на переменную или константу, которую нужно зарегистрировать.
       *
       *)
      Procedure PushVar(oVar: TConstant);
      
      (**
       * Метод выталкивания элемента.
       * Производит выталкивание ссылки из стека.
       *
       *)
      Function PopVar: TConstant;

      (**
       * Поиск переменной или константы по ее имени.
       *
       * Параметры:
       *   oName - лексема, значение которой будет использоваться для поиска ссылки.
       *
       * Возвращает ссылку на элемент стека, если было найдено совпадение, или nil, если нет.
       *
       *)
      Function FindVar(oName: TToken): TVarStackItem;

      // Число ссылок в стеке
      Property Count: integer read GetCount;

      // Позволяет получить ссылку на элемент стека по его условному индексу.
      Property Stack[iIndex: integer]: TVarStackItem read GetVar; default;

      // Ссылка на текущий локальный скрипт
      Property CurrentScript: TScript read FLocalScript;

      // Ссылка на основной скрипт
      Property MainScript: TScript read FMainScript write FMainScript;
  end;

  (**
   * Класс элемента стека переменных.
   * Неразрывно связан с классом TVarStack. Объекты самостоятельно добавляются и удаляются.
   *
   *)
  TVarStackItem = class
    Private

      // Ссылка на "родительский" стек, в котором содержится данный элемент.
      FParent: TVarStack;

      // Ссылка на скрипт, относительно которого переменная считается локальной.
      FScript: TScript;

      // Ссылка на переменную или константу, для которой заведен данный элемент.
      FValue: TConstant;

    Public
      
      (**
       * Конструктор элмента.
       * Самостоятельно производит вставку своей ссылки в родительский стек.
       *
       * Параметры:
       *   oParent - ссылка на стек, в котором заводится данный элемент
       *   oValue  - ссылка на константу или переменную, для которой заводится элемент.
       *
       *)
      constructor Create(oParent: TVarStack; oValue: TConstant);
      
      (**
       * Деструктор элемента.
       * Самостоятельно производит удаление своей ссылки из родительского стека.
       *
       *)
      destructor Destroy; override;

      // Ссылка на родительский стек
      Property Parent: TVarStack read FParent;
      
      // Ссылка на локальный скрипт
      Property Script: TScript read FScript;
      
      // Ссылка на хранимую переменную или константу.
      Property Value: TConstant read FValue;
  end;

  (**
   * Стек функций. Работает полностью аналогично стеку переменных, за исключением только лишь того,
   * что хранит в себе ссылки на объекты класса TFunction.
   *
   *)
  TFuncStack = class
    Private

      // Хранилище ссылок на переменные и константы, тут будут содержаться ссылки на TFuncStackItem
      FStack: TList;

      // Ссылка на текущий локальный скрипт
      FLocalScript: TScript;

      // Ссылка на основной скрипт программы
      FMainScript: TScript;

    Protected
      
      (**
       * Производит вставку элемента в стек.
       * Вызывается автоматически в конструкторе класса TFuncStackItem.
       *
       * Параметры:
       *   oFunc - ссылка на элемент, который надо вставить.
       *
       *)
      Procedure AddFunc(oFunc: TFuncStackItem);
      
      (**
       * Производит выталкивание элемента из стека.
       * Вызывается автоматически в деструкторе класса TFuncStackItem.
       *
       * Параметры:
       *   oFunc - ссылка на элемент, который надо вытолкнуть.
       *
       *)
      Procedure RemFunc(oFunc: TFuncStackItem);

      (**
       * Возвращает ссылку на элемент стека по его условному индексу.
       *
       * Параметры:
       *   iIndex - условный индекс, по которому нужно получит функцию.
       *
       * Возвращает ссылку на элемент, если все в порядке, или nil, если по индексу не
       * нашлось элемента.
       *
       *)
      Function GetFunc(iIndex: integer): TFuncStackItem;
      
      (**
       * Возвращает количество ссылок в хранилище на данное время.
       *
       *)
      FUnction GetCount: integer;

    Public
      
      (**
       * Конструктор стека.
       * Дополнительно, создает объект хранилища ссылок.
       *
       *)
      constructor Create;
      
      (**
       * Деструктор стека.
       * Очищает стек и удаляет объект хранилища.
       *
       *)
      Destructor Destroy; override;

      (**
       * Полностью очищает стек.
       *
       *)
      Procedure Clear;
      
      (**
       * Интерфейс входа в скрипт.
       * Устанавливает новый локальный скрипт.
       *
       * Параметры:
       *   oScript - скрипт, который будет локальным
       *
       *)
      Procedure EnterScript(oScript: TScript);

      (**
       * Интерфейс выхода из скрипта.
       * Выталкивает все ссылки для локального скрипта и изменяет ссылку на сам локальный скрипт.
       *
       * Параметры:
       *   oScript - Ссылка на скрипт, относительно которого выполняется метод выхода.
       *             По умолчанию это текущий локальный скрипт.
       *
       *)
      Procedure LeaveScript(oScript: TScript = nil);

      (**
       * Метод вставки элемента.
       * Производит вставку переменной для текущего локального скрипта.
       *
       * Параметру:
       *   oFunc - ссылка на функцию, которую нужно зарегистрировать.
       *
       *)
      Procedure PushFunc(oFunc: TFunction);
      
      (**
       * Метод выталкивания элемента.
       * Производит выталкивание ссылки из стека.
       *
       *)
      Function PopFunc: TFunction;

      (**
       * Поиск функции по ее имени.
       *
       * Параметры:
       *   oName - лексема, значение которой будет использоваться для поиска ссылки.
       *
       * Возвращает ссылку на элемент стека, если было найдено совпадение, или nil, если нет.
       *
       *)
      Function FindFunc(oName: TToken): TFuncStackItem;

      // Число ссылок в стеке
      Property Count: integer read GetCount;
      
      // Позволяет получить ссылку на элемент стека по его условному индексу.
      Property Stack[iIndex: integer]: TFuncStackItem read GetFunc; default;
      
      // Ссылка на текущий локальный скрипт
      Property CurrentScript: TScript read FLocalScript;

      // Ссылка на основной скрипт
      Property MainScript: TScript read FMainScript write FMainScript;
  end;

  (**
   * Класс элемента стека функций.
   * Неразрывно связан с классом TFuncStack. Объекты самостоятельно добавляются и удаляются.
   * Этот стек используется в двух целях:
   *   1- Так называемый CallStack - стек вызовов функций, в котором показано, какие функции
   *      были вызваны для достижения данного кода.
   *   2- Стек определенных в коде функций.
   *
   * Как и переменные, функции тоже можно определять внутри других функций, тем самым создавая
   * иерархию инициализации функций.
   *
   *)
  TFuncStackItem = class
    Private

      // Ссылка на "родительский" стек, в котором содержится данный элемент.
      FParent: TFuncStack;

      // Ссылка на скрипт, относительно которого переменная считается локальной.
      FScript: TScript;

      // Ссылка на функцию, для которой заведен данный элемент.
      FValue: TFunction;

    Public
      
      (**
       * Конструктор элмента.
       * Самостоятельно производит вставку своей ссылки в родительский стек.
       *
       * Параметры:
       *   oParent - ссылка на стек, в котором заводится данный элемент
       *   oValue  - ссылка на функцию, для которой заводится элемент.
       *
       *)
      constructor Create(oParent: TFuncStack; oValue: TFunction);
      
      (**
       * Деструктор элемента.
       * Самостоятельно производит удаление своей ссылки из родительского стека.
       *
       *)
      destructor Destroy; override;

      // Ссылка на родительский стек
      Property Parent: TFuncStack read FParent;
      
      // Ссылка на локальный скрипт
      Property Script: TScript read FScript;
      
      // Ссылка на хранимую функцию.
      Property Value: TFunction read FValue;
  end;

  (**
   * Класс ошибки интерпретатора. Используется во время синтаксического анализа для создания
   * исключительной ситуации, в результате которой генерируется состояние ошибки с последующей
   * остановкой процесса анализа синтаксиса и сборки кода. 
   *
   *)
  TProcessorException = class(Exception)
    Private
      // Код возникшей ошибки
      FCode: TParserErrorState;

    Public
      
      (**
       * Конструктор исключения.
       *
       * Параметры:
       *   eCode - код возникшей ошибки.
       *
       *)
      Constructor Create(eCode: TParserErrorState);

      // Код возникшей ошибки
      Property ErrCode: TParserErrorState read FCode;
  end;

  (**
   * Класс процессора кода. Основной класс модуля. Сочитает в себе две функции - анализатор
   * синтаксиса и генератор кода, обе функции взаимноинтегрированы и неразрывны.
   * Так же содержит основной скрипт программы, который заполняет кодом во время анализа лексем
   * и генерации кода.
   *
   * Фактически генерация кода заключается в создании операторов в момент завершения разбора
   * синтаксиса определенной последовательности лексем.
   * То есть, заполняя операторами основной скрипт программы, процессор выполняет генерацию
   * исполняемого кода.
   *
   *)
  TCodeProcessor = class
    Private

      // Ссылка на лексический анализатор, из которого будут браться лексемы для анализа.
      FCode: TStringTokenizer;

      // Ссылка на основной скрипт программы.
      FScript: TScript;

      // Показатель состояния ошибки.
      FError: TParserErrorState;

      // Ссылка на лексему, при достижении которой возникла ошибка.
      FErrorToken: TToken;

      // Ссылка на стек скриптов.
      FScriptStack: TScriptStack;

      // Ссылка на стек лексем.
      FTokenStack: TTokenStack;

      // Ссылка на стек переменных.
      FVarStack: TVarStack;

      // Ссылка на стек вызовов функций.
      FFuncStack: TFuncStack;

      // Ссылка на стек инициализированных функций.
      FDeclFuncStack: TFuncStack;

    Protected
      
      (**
       * Производит генерацию состояния ошибки.
       *
       * Параметры:
       *   eCode - код возникшей ошибки.
       *
       *)
      Procedure SetError(eCode: TParserErrorState);
      
      (**
       * Выполняет детерминированный перевод символьного названия типа данных в бинарный вид.
       *
       * Параметры:
       *   oToken - лексема, содержащая название типа данных
       *
       * Возвращает бинарное представление типа данных, элемент множества TVariableType.
       * В случае какой либо ошибки возвращает vtINT, как тип по умолчанию.
       *
       *)
      Function GetTypecast(oToken: TToken): TVariableType;
      
      (**
       * Выполняет преобразование лексемы с числовой константой в ее бинарный,
       * типизированный эквивалент.
       *
       * Параметры:
       *   oVariable    - запись значения переменой, в которую будет записан результат
       *   oValue       - лексема, содержащая числовое значение
       *   eInitialType - Изначальный тип, к которому нужно привести значении при чтении лексемы
       *
       *)
      Procedure Token2Var(var oVariable: TVariableValue; oValue: TToken; eInitialType: TVariableType);

      (**
       * Фактический сигнал входа анализатора в подпрограмму.
       * Производит изменение локальных скриптов в стеках на текущий, если необходимо, выполняет
       * добавление элемента в стек вызовов функций, вставляет текущий скрипт в стек скриптов.
       *
       * Параметры:
       *   oScript - скрипт, разбор которого будет начат после выполнения метода.
       *
       *)
      Procedure PushScript(oScript: TScript);

      (**
       * Сигнал завершения разбора текущей подпрограммы.
       * Производит удаление локальных данных в стеках, сигнализирует о выходе из функций если нужно,
       * осуществляет выталкивание скрипта из стека скриптов.
       *
       *)
      Function PopScript: TScript;

      (**
       * Метод для базового разбора математических выражений. Используется для разбора изолированных
       * выражений, содержащих символ ";" в конце.
       *
       * Вход в метод эквивалентен правилу #Operation#
       *
       * Использует методы:
       *   SetError
       *   ParseExpressionSpec
       *
       *)
      Function ParseExpression: TConstant;
      
      (**
       * Метод непосредственного разбора математических выражений. Для разбора используется обратная
       * польская нотация с реализацией на двух стеках.
       *
       * Вход в метод эквивалентен правилу #OperBlock#
       *
       * Параметры:
       *   oMargin - лексема, достигнув которую необходимо завершить разбор.
       *
       * Использует методы:
       *   SetError
       *   Token2Var
       *   ReadHeaderCallFunc
       *
       *)
      Function ParseExpressionSpec(oMargin: TToken): TConstant;
      
      (**
       * Метод чтения заголовка цикла for.
       * Фактически этот метод разбирает специальное выражение между круглых скобок в конструкции:
       *   for(<Init>; <Cond>; <Step>){
       *
       * Вход в метод эквивалентен правилу #KwExprFOR#
       *
       * Параметры:
       *   oFOR - ссылка на оператор цикла for, для которого будет считан
       *
       * Использует методы:
       *   SetError
       *   ParseExpression
       *   ParseExpressionSpec
       *
       *)
      Procedure ReadHeaderFOR(oFOR: TExpressionFOR);
      
      (**
       * Метод чтения параметров вызова функции.
       * Фактически производит разбор выражения между круглых скобок в конструкции:
       *   <function name>(<Prm1>, <Prm2>, ...);
       * Не производит проверку числа необходимых для вызова параметров и числа считанных.
       *
       * Вход в метод эквивалентен правилу #CallFunc#
       *
       * Использует методы:
       *   SetError
       *   ParseExpressionSpec
       *
       *)
      Procedure ReadHeaderCallFunc(oCallFunc: TFunctionCall);
      
      (**
       * Метод чтения параметро вызова echo.
       * Работает полностью аналогично методу ReadHeaderCallFunc, только не делает проверку на
       * число фактических параметров, за ненадобностью...
       *
       * Вход в метод эквивалентен правилу #KwExprECHO#
       *
       * Использует методы:
       *   SetError
       *   ParseExpressionSpec
       *
       *)
      Procedure ReadHeaderEcho(oEcho: TExpressionECHO);

      (**
       * Основной метод разбора синтаксиса.
       * С него начинается разбор любой конструкции.
       *
       * Вход в метод эквивалентен правилу #S#
       *
       * Использует методы:
       *   ParseOperator
       *   ParseBaseKeyword
       *   ParseBaseOperation
       *   ParseBaseSymbol
       *
       *)
      Procedure ParseScript;

      (**
       * Метод разбора правил инициализации констант, переменных и функций.
       *
       * Вход в метод эквивалентен правилу #Operator#
       *
       * Использует методы:
       *   SetError
       *   PushScript
       *
       *)
      Procedure ParseOperator;
      
      (**
       * Метод разбора конструкций ключевых слов.
       *
       * Вход в метод эквивалентен правилу #Keyword#
       *
       * Использует методы:
       *   SetError
       *   PushScript
       *   ParseExpression
       *   ParseExpressionSpec
       *   ReadHeaderFOR
       *   ReadHeaderEcho
       *
       *)
      Procedure ParseBaseKeyword;
      
      (**
       * Метод разбора сложных математических выражений в коде.
       *
       * Метод является лишь шиной для ParseExpression из соображений безопасности кода
       *
       * Использует методы:
       *   SetError
       *   ParseExpression
       *
       *)
      Procedure ParseBaseOperation;

      (**
       * Метод разбора изолированных символов.
       * В целях оптимизации операций метод реализует поведение согласно двум правилам.
       *
       * Вход в метод эквивалентен правилам #SubBlock# и #SubBlockEnd#
       *
       * Использует методы:
       *   SetError
       *   PushScript
       *   PopScript
       *
       *)
      Procedure ParseBaseSymbol;

    Public

      (**
       * Конструктор процессора.
       * Создает объект основого скрипта программы и производит базовую инициализацию полей.
       *
       *)
      Constructor Create(oCode: TStringTokenizer);

      (**
       * Деструктор процесса.
       * Производит очистку занимаемых объектом рессурсов.
       *
       *)
      Destructor Destroy; override;

      (**
       * Запускает процесс синтаксического анализа.
       *
       * Возвращает true, если синтаксический анализ завершен без ошибок,
       * и false в любом другом случае.
       *
       *)
      Function Parse: boolean;

      (**
       * Выполняет сгенерированный код.
       *
       *)
      Procedure Run;

      // Ссылка на лексический анализатор процессора
      Property Code: TStringTokenizer read FCode;

      // Ссылка на основной скрипт программы
      Property Script: TScript read FScript;

      // Идентификатор последней ошибки
      Property LastError: TParserErrorState read FError;

      // Ссылка на лексему, при достижении которой было сгенерировано состояние ошибки
      Property ErrorToken: TToken read FErrorToken;
  end;

implementation
//--------------------------------------------------------------------------------------------------
//--- TCodeProcessor class body --------------------------------------------------------------------
(**
 * Конструктор процессора. Для создания процессора необходима ссылка на лексический анализатор.
 *
 * Параметры:
 *   oCode - ссылка на лексический анализатор, который будет использоваться для анализа синтаксиса.
 *
 *)
Constructor TCodeProcessor.Create(oCode: TStringTokenizer);
begin
  FCode := oCode;
  FScript := TScript.Create;
  FError := esOK;
  FErrorToken := nil;
  FScriptStack := nil;
  FTokenStack := nil;
  FVarStack := nil;
  FFuncStack := nil;
  FDeclFuncStack :=  nil;
end;

(**
 * Деструктор процессора.
 * В процессоре используется много динамически создаваемых объектов, все их надо освободить
 * до удаления самого процессора.
 *
 *)
Destructor TCodeProcessor.Destroy;
begin
  // Удаляем основной скрипт программы
  FScript.Free;

  // Проверяем, не осталось ли где живого объекта, если так, то удаляем его
  if FScriptStack <> nil then FScriptStack.Free;
  if FTokenStack <> nil then FTokenStack.Free;
  if FVarStack <> nil then FVarStack.Free;
  if FFuncStack <> nil then FFuncStack.Free;
  if FDeclFuncStack <> nil then FDeclFuncStack.Free;

  // Завершаем удаление вызовом родительского деструктора
  inherited Destroy;
end;

(**
 * Метод переводит процессор в состоянии ошибки. Используется только при синтаксическом анализе.
 * Для остановки процесса анализа используется механизм исключений (exception)
 *
 * Параметры:
 *   eCode - Код, показывающий, какая именно ошибки произошла
 *
 * Генерирует исключительную ситуцию
 *
 *)
Procedure TCodeProcessor.SetError(eCode: TParserErrorState);
begin
  // Меняем свое состояние на ошибку
  FError := eCode;
  // Запоминаем лексему, на которой остановились, как ошибочную лексему
  FErrorToken := FCode.Current;
  // Выкидываем исключение
  raise TProcessorException.Create(eCode);
end;

(**
 * Метод облегчает процесс перевода сивольного обозначения типа данных в значение, понятное процессору.
 * Переведет 'int' в vtINT, 'bool' - в vtBOOL, а 'float' переведет в vtFLOAT.
 *
 * Параметры:
 *   oToken - лексема с типом ttType, в которой содержится название типа данных
 *
 * Возвращает элемент TVariableType, которому подходит название типа из лексемы
 *
 *)
Function TCodeProcessor.GetTypecast(oToken: TToken): TVariableType;
var
  iPos: integer;
begin
  iPos := 1;
  // Перебираем все доступные типы данных и находим нужный
  while CI_TYPESCOUNT >= iPos do begin
    if oToken.Value = CA_TYPES[iPos] then break;
    inc(iPos);
  end;
  // обрезаем поисковый указатель по диапазону 0..3, так результат будет гарантировано определен.
  Result := TVariableType(iPos mod (CI_TYPESCOUNT+1));
end;

(**
 * Метод переводит строковое значение лексемы в значение переменной, поппутно делая приведение значения
 * к типу этой переменной.
 *
 * На вход подается лексема-числовая константа с типом ttNumINT или ttNumFLOAT.
 * Так же на вход передается переменная для записи туда результата и тип данных в этой переменной.
 * Необходимо произвести адекватный перевод значения лексемы в переменную результата с правильным
 * приведением данных.
 * Метод целиком решает данную задачу, после работы метода в параметре oVariable будет находиться
 * числовой эквивалент значению, содержащемуся в лексеме.
 *
 * Параметры:
 *   oVariable    - запись значения переменой, в которую будет записан результат
 *   oValue       - лексема, содержащая числовое значение
 *   eInitialType - Изначальный тип, к которому нужно привести значении при чтении лексемы
 *
 *)
Procedure TCodeProcessor.Token2Var(var oVariable: TVariableValue; oValue: TToken; eInitialType: TVariableType);
begin
  // А вдруг метод вызвали неправильно или не из того места, надо бы сообщить об ошибке в этом случае.
  if not (oValue.TokenType in [ttNumINT, ttNumFLOAT, ttDigit]) then SetError(esUnexpSymbol);

  // Обнуляем все 4 байта у результата
  oVariable.iValue := 0;

  // Смотрим, вещественное ли число записано?
  if Pos('.', oValue.Value) > 0 then begin
    // Это вещественное, теперь его надо привести к типу результата
    case eInitialType of
      vtINT: begin
        // Обрезаем строку, удаляем всю правую часть вместе с точкой, целую пишем в результат
        oVariable.iValue := StrToIntDef(copy(oValue.Value, 1, Pos('.', oValue.Value)-1), 0);
      end;
      vtFLOAT: begin
        // Испрваляем разделитель десятичной части, а затем напрямую переводим вещественное
        oVariable.fValue := StrToFloatDef(StringReplace(oValue.Value, '.', ',', [rfReplaceAll]), 0.0);
      end;
      vtBOOL: begin
        // Работаем со значением как с целым, но из целого извлекаем логическое значение - true или false
        oVariable.bValue := StrToIntDef(copy(oValue.Value, 1, Pos('.', oValue.Value)-1), 0) <> 0;
      end;
    end;
  end else begin
    // В лексеме записано целое число, его в результат переводим так :
    case eInitialType of
      vtINT: begin
        // Целое в целое, напрямую переводим, без проблем должно быть
        oVariable.iValue := StrToIntDef(oValue.Value, 0);
      end;
      vtFLOAT: begin
        // целую строчку в вещественное вот так тоже без проблем пройдет
        oVariable.fValue := StrToFloatDef(oValue.Value, 0.0);
      end;
      vtBOOL: begin
        // Логическое - это то же самое целое, только значим у него всего 1 первый бит, переводим и сравниваем для получения значения.
        oVariable.bValue := StrToIntDef(oValue.Value, 0) <> 0;
      end;
    end;
  end;
end;

(**
 * Позволяет сигнализировать о начале разбора очередной подпрограммы.
 *
 * Парметры:
 *   oScript - скрипт, куда будет генерироваться код разбираемой далее подпрограммой.
 *
 *)
Procedure TCodeProcessor.PushScript(oScript: TScript);
begin
  // Производим вставку скрипта в глову стека скриптов, далее код будет генерироваться в этом скрипте.
  FScriptStack.Push(oScript);
  // Входим в локальное пространство этого скрипта, новые переменные будут локальными для него
  FVarStack.EnterScript(oScript);
  // Если в этой подпрограмме обнаружится объявление функции, функция будет локальна для этого скрипта
  FFuncStack.EnterScript(oScript);
  FDeclFuncStack.EnterScript(oScript);
end;

(**
 * Позволяет сигнализировать о завершении разбора подпрограммы.
 *
 * Возвращает ссылку на только что вытолкнутый скрипт, или nil, если стек скриптов был пуст.
 *
 *)
Function TCodeProcessor.PopScript: TScript;
begin
  Result := nil;
  // выходим, если стек скриптов итак пуст.
  if FScriptStack.Count < 1 then abort;
  // Производим выход из локального пространства разбираемого скрипта
  FDeclFuncStack.LeaveScript(FScriptStack.Script[0]);
  FFuncStack.LeaveScript(FScriptStack.Script[0]);
  FVarStack.LeaveScript(FScriptStack.Script[0]);
  // Теперь все локальные для скрипта функции и переменные стали невидимыми для операторов
  // Выталкиваем скрипт из стека скриптов и переписываем ссылку на него для возврата значения.
  Result := FScriptStack.Pop;
  // Скрипт перестал быть локальным, теперь локальным становится его родительский скрипт.
end;

(**
 * интерфейс запуска синтаксического анализа.
 * На время синтаксического анализа лексический анализатор (FScript) ставновится итератором
 * лексем. Считается, что в нем уже есть набор лексем и осталось их только разборать.
 * Как итератор, лексический анализатор способен выполнять лишь несколько действий:
 *   - Current : возвращает текущую лексему.
 *   - Next    : перемещает итератор на следующую лексему.
 *   - EOF     : показывает, достигнута ли последняя лексема? Вернет true, если достгнута.
 *   - Rewind  : сбрасывает итератор в состояние начала, перемещает его на самую первую лексему.
 * Во время анализа синтаксиса процессор использует только эти методы.
 *
 * Возвращает true, если весь код был разобран корректно, или false в случае ошибки.
 *
 *)
Function TCodeProcessor.Parse: boolean;
begin
  // Сбрасываем итератор лексем
  FCode.Rewind;
  // Чистим комменты, чтоб в коде больше небыло комментариев
  FCode.ClearComments;
  // Сбрасываем состояние ошибки
  FError := esOK;
  FErrorToken := nil;

  // Создаем структуры для синтаксического анализа
  FScriptStack    := TScriptStack.Create;  // Стек скриптов
  FTokenStack     := TTokenStack.Create;   // Стек лексем
  FVarStack       := TVarStack.Create;     // Стек инициализированных переменных
  FFuncStack      := TFuncStack.Create;    // Стек вызовов функций
  FDeclFuncStack  := TFuncStack.Create;    // Стек инициализированных функций

  // Устанавливаем основной скрипт программы как основной для стеков переменных и функций
  FVarStack.MainScript      := FScript;
  FFuncStack.MainScript     := FScript;
  FDeclFuncStack.MainScript := FScript;

  // Сигнализируем о входе в основную программу
  PushScript(FScript);
  // Запускаем анализ синтаксиса
  if FCode.Count > 0 then ParseScript;
  // Сигнализируем о выходе из основной программы, если при этом естьошибка, то сигнализируем об этом
  if (FError = esOK) and (PopScript <> FScript) then FError := esScriptStackError;

  // Удаляем структуры для синтаксического анализа. больше они не нужны
  FScriptStack.Free;
  FTokenStack.Free;
  FVarStack.Free;
  FFuncStack.Free;
  FDeclFuncStack.Free;

  // Сбрасываем ссылки, чтоб деструктор не удалял их в пустую
  FScriptStack    := nil;
  FTokenStack     := nil;
  FVarStack       := nil;
  FFuncStack      := nil;
  FDeclFuncStack  := nil;

  // Завершаем разбор и отдаем результат наружу
  Result := FError = esOK;
end;

(**
 * Интерфейс исполнения кода программы.
 * После успешного синтаксического анализа можно вызвать этот метод, что приведет к выполнению
 * изложенного в исходном коде алгоритма.
 * Фактически этот метод ни чем не отличается от обращения CodeProcessor.Script.Run.
 *
 *)
Procedure TCodeProcessor.Run;
begin
  // Просто запускаем выполнение основного скрипта программы
  FScript.Run;
end;

(**
 * Основной метод синтаксического анализа.
 * Отражает правило #S# для разбора выражений.
 *
 *)
Procedure TCodeProcessor.ParseScript;
begin
  // Будем продолжать разбор, пока в итераторе не кончатся лексемы
  while not (FCode.EOF or (FError <> esOK)) do begin
    try
      // На основании типа текущей лексемы делаем вывод, какое правило разбора брать дальше
      case FCode.Current.TokenType of
        ttType:    ParseOperator;       // В разбор инициализацию функций, констант и переменных
        ttKeyword: ParseBaseKeyword;    // В разбор ключевых слов
        ttIdent:   ParseBaseOperation;  // В разбор математических выражений
        ttSymbol:  ParseBaseSymbol;     // В разбор свободных символов

        else SetError(esUnexpSymbol);   // А если тип непонятен, то генерируем ошибку
      end;
    except
      // Область разбора ошибок.

      // Любая сторонняя ошибка должна быть передана наружу
      on oInterrupt: TProcessorException do begin
        ErrorReport(oInterrupt.Message);
      end;

      // Любая внутренняя ошибка должна быть собрана
      on oInterrupt: Exception do begin
        ErrorReport(oInterrupt.Message);
      end;
    end;
  end;
end;

(**
 * Метод разбора правил инициализации констант, переменных и функций.
 *
 * Вход в метод эквивалентен правилу #Operator#
 *
 * Метод производит анализ синтаксиса и генерацию кода объявлений констант, переменных и функций.
 *
 *)
Procedure TCodeProcessor.ParseOperator;
var
  // Флаг, показывающий, константный ли тип инициализируется
  bIsConst: boolean;
  // Ссылка на сгенерированный оператор
  oOperator: TBaseOperator;
  // Ссылка для хранения различных значений, просто помошник для содержания ссылки
  oHelper: TConstant;
  // Переменная для определения значений переменных и констант в момент их инициализации
  oVar: TVariableValue;
  // Используется для промежуточного определения типа используемых данных
  eVType: TVariableType;
  // Используется для промежуточного хранения ссылки на элемент стека переменных
  oStackedVar: TVarStackItem;
  oStackedFunc: TFuncStackItem;
  // Определяет количество фактических параметров при объявлении функции
  iFuncPrmCnt: integer;

begin
  // Сперва сбрасываем флаг костантного типа
  bIsConst := false;
  // А потом проверяем, не находится ли ключевое слово в стеке лексем
  if FTokenStack.Count > 0 then bIsConst := FTokenStack.Token[0].Value = 'const';

  // Кладем в стек лексем лексему с типом данных и переходим к следующей лексеме
  FTokenStack.Push(FCode.Current); // стек лексем +1
  FCode.Next;

  // Сейчас должен быть только идентификатор, если что то другое, значит это ошибка
  if FCode.Current.TokenType = ttIdent then begin
    // Запоминаем идентификатор
    FTokenStack.Push(FCode.Current); // стек лексем +2
    FCode.Next;

    // Теперь могут быть варианты: ";", "=" или "(" , но если что то другое, значит ошибка
    if FCode.Current.TokenType <> ttSymbol then SetError(esUnexpSymbol);
    if FCode.Current.Value = ';' then begin
      // Сперва надо проверить, а не определена ли уже такая переменная в локальном пространстве?
      oStackedVar := FVarStack.FindVar(FTokenStack.Token[0]);
      if (oStackedVar <> nil) and (FScriptStack.Script[0] = oStackedVar.Script) then SetError(esVarIsDuped);
      // Определяется переменная без инициализации - "int i;"
      // По умолчанию все переменные инициализируются нулем.
      oVar.iValue := 0;

      // Но попытка определить константу без инициализации, это ошибка
      if bIsConst then
        SetError(esConstNotInit)
      else begin
        // генерируем код соответствующего оператора
        oOperator := TVariable.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
        TVariable(oOperator).Init(oVar, GetTypecast(FTokenStack.Token[1]));
        // Обязательно добавляем переменную в стек переменных, а то ее не будет видно
        FVarStack.PushVar(TVariable(oOperator));
      end;

      // в стеке есть от 2 или 3 значимых лексемы, разбор завершен и их теперь надо вытолкнуть
      FTokenStack.Pop;
      FTokenStack.Pop;
      if bIsConst then FTokenStack.Pop;
    end else if FCode.Current.Value = '=' then begin
      // Сперва надо проверить, а не определена ли уже такая переменная в локальном пространстве?
      oStackedVar := FVarStack.FindVar(FTokenStack.Token[0]);
      if (oStackedVar <> nil) and (FScriptStack.Script[0] = oStackedVar.Script) then SetError(esVarIsDuped);
      // Опредедляется переменная или константа, есть инициализация.
      FCode.Next;
      // определили предварительно тип данных
      eVType := GetTypecast(FTokenStack.Token[1]);

      case FCode.Current.TokenType of
        // Инициализация производится через числовое значение, это не сложно
        ttNumINT, ttNumFLOAT: Token2Var(oVar, FCode.Current, eVType);
        // Инициализация производится перекрестно, через другую переменную или константу, это интереснее
        ttIdent: begin
          // Находим указанную переменную в списке, если такой не нашлось, значит ошибка
          oStackedVar := FVarStack.FindVar(FCode.Current);
          if oStackedVar <> nil then begin
            // Производим перекрестное присваивание. Возможно тут тоже будет уместно использовать CA_LETMATRIX
            case eVType of
              vtINT: begin
                if oStackedVar.Value.Typecast = vtFLOAT then oVar.iValue := Floor(oStackedVar.Value.Value.fValue)
                else oVar.iValue := oStackedVar.Value.Value.iValue;
              end;
              vtFLOAT: begin
                case oStackedVar.Value.Typecast of
                  vtINT: oVar.fValue := oStackedVar.Value.Value.iValue;
                  vtBOOL: oVar.fValue := 0.0;
                  vtFLOAT: oVar.fValue := oStackedVar.Value.Value.fValue;
                end;
              end;
            end;
          end else SetError(esUnknownVar);
        end;
        else SetError(esUnexpSymbol);
      end;

      // Считали параметр инициализации, теперь должна стоять строго ";", иначе ошибка
      FCode.Next;
      if FCode.Current.Value <> ';' then SetError(esUnexpSymbol);

      // Весь синтаксис разобран, остается только сгенерировать нужный оператор - переменную или константу
      if bIsConst then begin
        oOperator := TConstant.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
        TConstant(oOperator).Init(oVar, eVType);
      end else begin
        oOperator := TVariable.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
        TVariable(oOperator).Init(oVar, eVType);
      end;
      // Обязательно добавляем переменную в стек переменных, а то ее не будет видно
      FVarStack.PushVar(TConstant(oOperator));

      // в стеке есть от 2 или 3 значимых лексемы, разбор завершен и их теперь надо вытолкнуть
      FTokenStack.Pop;
      FTokenStack.Pop;
      if bIsConst then FTokenStack.Pop;
    end else if FCode.Current.Value = '(' then begin
      // Сперва надо проверить, а не определена ли уже такая функция в локальном пространстве?
      oStackedFunc := FDeclFuncStack.FindFunc(FTokenStack.Token[0]);
      if (oStackedFunc <> nil) and (FScriptStack.Script[0] = oStackedFunc.Script) then SetError(esVarIsDuped);
      // Определяется заголовок функции, сразу за ним должно идти описание ее подпрограммы
      FCode.Next;

      // Синтаксис заголовка уже разобран, поэтому можно провести генерацию кода - создать оператор функции
      oVar.iValue := 0;
      eVType := GetTypecast(FTokenStack.Token[1]);
      oOperator := TFunction.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
      // Сразу добавляем функцию в стек вызовов функций и в стек инициализированных функций
      FFuncStack.PushFunc(TFunction(oOperator));
      FDeclFuncStack.PushFunc(TFunction(oOperator));
      // Переходим к разбору подпрограммы функции
      PushScript(TFunction(oOperator).Action);

      iFuncPrmCnt := 0;
      // Особенность - параметры функции это такие же переменные подпрограммы функции
      // Параметры - это несколько предопределенных в самом начале подпрограммы переменных
      // Именно этот блок и занимается генерацией кода параметров функции
      while FCode.Current.Value <> ')' do begin
        // В начале, каждому параметру дается тип, если типа нет - ошибка
        if FCode.Current.TokenType <> ttType then SetError(esUnexpSymbol);
        FTokenStack.Push(FCode.Current); // Запоминаем тип, стек +3
        FCode.Next;

        // следом за типом должно идти имя параметра, если нет - ошибка
        if FCode.Current.TokenType <> ttIdent then SetError(esUnexpSymbol);
        // Если все ормально, генерируем код параметра
        oHelper := TVariable.Create(FScriptStack.Script[0], FCode.Current);
        oHelper.Init(oVar, GetTypecast(FTokenStack.Token[0]));
        // Да да, даже параметр должен быть внесен в стек переменных, как локальная переменная
        // подпрограммы функции, а иначе как ее найти потом?
        FVarStack.PushVar(oHelper);

        // Параметрам функции +1
        inc(iFuncPrmCnt);
        FCode.Next;

        FTokenStack.Pop; // выталкиваем лексему типа, стек +2
        // если попалась закрывающая скобка - останавливаем цикл инициализации параметров
        if FCode.Current.Value = ')' then continue;
        // если встретилась запятая, значит следом должен быть еще параметр, а если нет - ошибка
        if FCode.Current.Value <> ',' then SetError(esUnexpSymbol);
        FCode.Next;
      end;
      FCode.Next;

      // Теперь должна быть лексема начала подпрограммы, ну никак без нее дальше, так что если нет - ошибка
      if FCode.Current.Value <> '{' then SetError(esUnexpSymbol);
      // Вот только теперь можно производить инициализацию оператора функции
      TFunction(oOperator).Init(iFuncPrmCnt, eVType);

      // в стеке есть от 2 или 3 значимых лексемы, разбор завершен и их теперь надо вытолкнуть
      FTokenStack.Pop;
      FTokenStack.Pop;
      if bIsConst then FTokenStack.Pop;
    end else SetError(esUnexpSymbol);
  end else SetError(esUnexpSymbol);
  // В конце концов, от разбора всегда остается лексема символа - "{" или ";",
  // ее нужно просто проскочить, т.к. ее смысл уже учтен в ходе данного метода
  Fcode.Next;
end;

(**
 * Метод для базового разбора математических выражений. Используется для разбора изолированных
 * выражений, содержащих символ ";" в конце.
 *
 * Вход в метод эквивалентен правилу #Operation#
 *
 * Это лишь промежуточный ход для разбора математического выраженя в виде обособленой операции
 *
 *)
Function TCodeProcessor.ParseExpression: TConstant;
var
  // Бегунок по лексемам
  oWalker: TToken;
  // счетчик скобочек в выражении, служит для проверки правильности расстановки скобок
  iBrekets: integer;
begin
  // скобок ноль
  iBrekets := 0;
  // запоминаем текущую лексему, теперь итерирование будет условным
  oWalker := FCode.Current;
  // Надо найти какую нибудь лексему, которая уж точно сигнализировала бы о конце текущего выражения
  // Это может быть ";" в хорошем случае, или "{" в отдельных случаях
  // Но во время поиска следует всегда помнить, что лексемы могут кончиться, это произойдет тогда
  // когда oWalker станет равен nil.
  while (oWalker <> nil) do begin
    case oWalker.Value[1] of
      '(':     inc(iBrekets); // есть открывающая скобочка, счетчик в плюс
      ')':     dec(iBrekets); // для каждой открывающей должна быть закрывающая, счетчик в минус
      ';','{': break;         // Нужная граница нашлась, теперь выражение имеет свою длину
    end;

    // было слишком много закрывающих скобочек, это определенно ошибка
    if iBrekets < 0 then break;

    // Это не приведет к изменению лексемы в .Current, но позволит увидеть лексемы дальше по коду
    oWalker := oWalker.Next;
  end;
  // Если есть дисбаланс в скобочках или был достигнут конец кода, значит где то явно есть ошибка
  if (iBrekets <> 0) or (oWalker = nil) then SetError(esUnclosedExpression);

  // Граница разбора определена и все в порядке, уходим непосредственно в разбор выражения
  Result := ParseExpressionSpec(oWalker);
end;

(**
 * Метод непосредственного разбора математических выражений. Для разбора используется обратная
 * польская нотация с реализацией на двух стеках.
 *
 * Вход в метод эквивалентен правилу #OperBlock#
 *
 * Параметры:
 *   oMargin - лексема, достигнув которую необходимо завершить разбор.
 *
 *)
Function TCodeProcessor.ParseExpressionSpec(oMargin: TToken): TConstant;
var
  // Левый операнд генерируемого выражения, используется очень часто
  oLeft: TConstant;
  // Правый операнд выражения, на удивление, используется не так часто как левый
  oRight: TConstant;
  // Маячек для запоминания текущего состояние стека лексем, чтоб сохранить целостность данных
  iStackState: integer;
  // Стек операторов разбираемого выражения
  oOutStack: TVarStack;
  // Значение для инициализации числовых констант
  oVar: TVariableValue;
  // Используется как сигнализатор, что дльше должен быть только символ операции
  bNeedSymbol: boolean;
  // В помощь для поиска переменных и функций
  oVarHelper: TVarStackItem;
  oFuncHelper: TFuncStackItem; 

  (**
   * Постоянно повторяющаяся конструкция, легче использовать как подфункцию.
   * Используется для генерации кода операции из лексемы.
   * Куда легче было бы использовать фабрику... но не сейчас.
   *
   *)
  Function CreateOperation(oOpToken: TToken): TConstant;
  begin
    Result := nil;
    case oOpToken.Value[1] of
      '+': Result := TOperationADD.Create(FScriptStack.Script[0], oOpToken);
      '-': Result := TOperationSUB.Create(FScriptStack.Script[0], oOpToken);
      '*': Result := TOperationMUL.Create(FScriptStack.Script[0], oOpToken);
      '/': Result := TOperationDIV.Create(FScriptStack.Script[0], oOpToken);
      '%': Result := TOperationMOD.Create(FScriptStack.Script[0], oOpToken);
      '!': begin
        if oOpToken.Value = '!=' then begin
          Result := TOperationEQUAL.Create(FScriptStack.Script[0], oOpToken);
        end else begin
          Result := TOperationNOT.Create(FScriptStack.Script[0], oOpToken);
        end;
      end;
      '>': Result := TOperationABOVE.Create(FScriptStack.Script[0], oOpToken);
      '<': Result := TOperationBELOW.Create(FScriptStack.Script[0], oOpToken);
      '&': Result := TOperationAND.Create(FScriptStack.Script[0], oOpToken);
      '|': Result := TOperationOR.Create(FScriptStack.Script[0], oOpToken);
      '^': Result := TOperationXOR.Create(FScriptStack.Script[0], oOpToken);
      '=': begin
        if oOpToken.Value = '==' then begin
          Result := TOperationEQUAL.Create(FScriptStack.Script[0], oOpToken);
        end else begin
          Result := TOperationLET.Create(FScriptStack.Script[0], oOpToken);
        end;
      end;
    end;
    if Result <> nil then Result.Flags := Result.Flags + [ofTraceOff];
  end;

begin
  // Создаем стек операторов, он нужен только тут.
  oOutStack := TVarStack.Create;
  // входим в текущий локальный скрипт, необходимая операция
  oOutStack.EnterScript(FScriptStack.Script[0]);
  // Сбрасываем все переменные, чтоб небыло казусов, и запоминаем текущее положение стека лексем
  oLeft := nil;
  oRight := nil;
  Result := nil;
  iStackState := FTokenStack.Count;
  bNeedSymbol := false;

  // Начинаем проход, будем продолжать разбор пока не встретится конец кода или конец выражения
  while (not FCode.EOF) and (FCode.Current <> oMargin) do begin
    // При разбюоре мы можем встретить лексемы только трех типов: символ, число, идентификатор или ключевое слово
    // все другие лексемы в выражении - это ошибка
    case FCode.Current.TokenType of

      // Обрабатываем символы операций
      ttSymbol: begin
        case FCode.Current.Value[1] of
          // Тут стоит принудительно завершить разбор
          ';','{': break;

          // Встретили символ операции
          '+','-','*','/','%','>','<','!','=','&','|','^': begin
            // если что то не так, параметров для свертывания операции слишком мало, это ошибка
            if (oOutStack.Count < 1) and (FCode.Current.Value <> '!') then SetError(esUnclosedExpression);

            // в стеке лексем наверное есть более приоритетные операции, чем текущая, их нужно
            // свернуть в операторы, но при встрече символа присваивания надо остановиться
            // Присваивание сворачивается в самом конце всегда, даже если их подряд несколько было
            if (FTokenStack.Count > iStackState) and (FCode.Current.Value <> '=') then begin
              while GetOperatorOrder(FCode.Current.Value) <= GetOperatorOrder(FTokenStack.Token[0].Value) do begin
                // если осталась открывающая скобочка, то останавливаемся
                if FTokenStack.Token[0].Value = '(' then break;
                // Создаем оператор из операции
                oLeft := CreateOperation(FTokenStack.Token[0]);
                // оператор "НЕ" является унарным, ему нужен тольк один операнд из стека, остальным - два
                if FTokenStack.Token[0].Value = '!' then begin
                  // Достаем из стека операнд и передаем его в оператор, затем выталкиваем операнд из стека
                  TOperation(oLeft).Init(oOutStack.Stack[0].Value, nil);
                  oOutStack.PopVar;
                end else begin
                  // операндов в стеке слишком мало, что то значит не так, значит ошибка
                  if (oOutStack.Count < 2) or (not bNeedSymbol) then SetError(esUnclosedExpression);
                  // инициализируем операцию двумя операндами из стека и выталкиваем их
                  TOperation(oLeft).Init(oOutStack.Stack[1].Value, oOutStack.Stack[0].Value);
                  oOutStack.PopVar;
                  oOutStack.PopVar;
                end;
                // а теперь кладем операцию в стек, теперь это один из операндов
                oOutStack.PushVar(oLeft);
                // забываем лексему операции, она больше не нужна
                FTokenStack.Pop;
              end;
            end;
            // Запоминаем текущую операцию в стек лексем и сбрасываем сигнализатор
            FTokenStack.Push(FCode.Current);
            bNeedSymbol := false;
          end;

          // для открывающих скобочек отдельный разбор
          '(': begin
            // кладем скобочку в стек, так приоритеты операций будут разделены
            FTokenStack.Push(FCode.Current);
          end;

          // с закрывающими скобочками тоже все отдельно
          // Теперь необходимо сделать свертывание всех операций в скобочках, таким образом
          // вся скобочка станет одним оператором, с которым тоже можно будет взаимодействовать 
          ')': begin
            // если что то не так, параметров для свертывания операции слишком мало, это ошибка
            if oOutStack.Count < 1 then SetError(esUnclosedExpression);

            // пока не встретилась парная этой скобочка, надо производить сворачивание операций
            while (FTokenStack.Count > iStackState) and (FTokenStack.Token[0].Value <> '(') do begin
              // Создаем оператор по лексеме операций
              oLeft := CreateOperation(FTokenStack.Token[0]);
              // Выполняем пляску с параметрами, удаляем их из стека, чтоб небыло ошибок
              if FTokenStack.Token[0].Value = '!' then begin
                TOperation(oLeft).Init(oOutStack.Stack[0].Value, nil);
                oOutStack.PopVar;
              end else begin
                if oOutStack.Count < 2 then SetError(esUnclosedExpression);
                TOperation(oLeft).Init(oOutStack.Stack[1].Value, oOutStack.Stack[0].Value);
                oOutStack.PopVar;
                oOutStack.PopVar;
              end;
              // А под конец вставляем в стек новый оператор, теперь с ним можно связывать другие операции
              oOutStack.PushVar(oLeft);
              // И удаляем лексему операции из стека
              FTokenStack.Pop;
            end;

            // Свертывание завершено, стоит только лишний раз удостовериться в правильности
            // если по каким то причинам в голове стека не стоит скобочка, это ошибка
            if FTokenStack.Token[0].Value <> '(' then SetError(esUnclosedExpression);

            // Удаляем из стека скобочку и говорим, что дальше должен быть только символ
            FTokenStack.Pop;
            bNeedSymbol := true;
          end;

          // А если что то другое, то ошибка
          else SetError(esUnexpSymbol);
        end;
      end;

      // Обрабатываем идентификаторы - переменные, константы и функции
      ttIdent: begin
        if FCode.Current.Next.Value = '(' then begin
          // Если следующая лексема - скобочка, значит этот идентификатор - функция и это ее вызов
          // Генерируем оператор вызова функции
          oLeft := TFunctionCall.Create(FScriptStack.Script[0], FCode.Current);
          FCode.Next;

          // Проверяем, а определена ли вобще такая функция в коде? Если нет - ошибка
          oFuncHelper := FDeclFuncStack.FindFunc(oLeft.Name);
          if oFuncHelper = nil then SetError(esUndeclFunc);
          oRight := oFuncHelper.Value;
          if oRight = nil then SetError(esUndeclFunc);

          // Читаем переданные в вызов параметры
          ReadHeaderCallFunc(TFunctionCall(oLeft));
          // Инициализируем и выставляем флаги оператора
          with TFunctionCall(oLeft) do begin
            Init(TFunction(oRight));
            Flags := Flags + [ofTraceOff];
          end;
          // Добавляем оператор в стек
          oOutStack.PushVar(oLeft);
        end else begin
          // А иначе - это какая то переменная или константа
          // Надо только разобраться, определена ли такая переменная, или еще нет
          oVarHelper := FVarStack.FindVar(FCode.Current);
          if oVarHelper = nil then SetError(esUndeclVar);
          oLeft := oVarHelper.Value;
          if oLeft = nil then SetError(esUndeclVar);
          // Добавляем переменную в стек
          oOutStack.PushVar(oLeft);
        end;
        bNeedSymbol := true;
      end;

      // Обрабатываем числовые константы - целые числа
      ttNumINT: begin
        // Такие числа и генерируются как константы в скрипте, с одной доработкой
        // Такое число сразу же переводится в ofNotActive, чтоб не допускать его
        // регистрации как константы
        oLeft := TConstant.Create(FScriptStack.Script[0], FCode.Current);
        oLeft.Flags := oLeft.Flags + [ofNotActive,ofTraceOff];
        Token2Var(oVar, FCode.Current, vtINT);
        oLeft.Init(oVar, vtINT);
        oOutStack.PushVar(oLeft);
        bNeedSymbol := true;
      end;

      // Обрабатываем числовые константы - вещественные числа
      ttNumFLOAT: begin
        oLeft := TConstant.Create(FScriptStack.Script[0], FCode.Current);
        oLeft.Flags := oLeft.Flags + [ofNotActive,ofTraceOff];
        Token2Var(oVar, FCode.Current, vtFLOAT);
        oLeft.Init(oVar, vtFLOAT);
        oOutStack.PushVar(oLeft);
        bNeedSymbol := true;
      end;

      // Обрабатываем ключевые слова, значимыми из всех явяются толкьо слова true и false
      // все другие слова в выражении являются ошибкой
      ttKeyword: begin
        // Сбрасываем значение оператора
        oVar.iValue := 0;
        if FCode.Current.Value = 'true' then begin
          // true и false - это просто заметны для булевских констант, они и создаются ак константы
          oLeft := TConstant.Create(FScriptStack.Script[0], FCode.Current);
          oLeft.Flags := oLeft.Flags + [ofNotActive,ofTraceOff];
          oVar.bValue := true;
          oLeft.Init(oVar, vtBOOL);
          oOutStack.PushVar(oLeft);
          bNeedSymbol := true;
        end else if FCode.Current.Value = 'false' then begin
          oLeft := TConstant.Create(FScriptStack.Script[0], FCode.Current);
          oLeft.Flags := oLeft.Flags + [ofNotActive,ofTraceOff];
          oVar.bValue := false;
          oLeft.Init(oVar, vtBOOL);
          oOutStack.PushVar(oLeft);
          bNeedSymbol := true;
        end else SetError(esUnexpSymbol);
      end;

      else SetError(esUnexpSymbol);
    end;
    FCode.Next;
  end;

  // После разбора в стеках еще могут оставаться несвернутые операции, надо завершить сворачивание
  // В конце разбора в стеке операторов должен остаться только один оператор, являющийся
  // вершиной в дереве операторов
  while FTokenStack.Count > iStackState do begin
    // Создаем оператор по лексеме операций
    oLeft := CreateOperation(FTokenStack.Token[0]);
    // Достаем операторы из стека и связываем их с операцией
    if FTokenStack.Token[0].Value = '!' then begin
      if oOutStack.Count < 1 then SetError(esUnclosedExpression);
      TOperation(oLeft).Init(oOutStack.Stack[0].Value, nil);
      oOutStack.PopVar;
    end else begin
      if oOutStack.Count < 2 then SetError(esUnclosedExpression);
      TOperation(oLeft).Init(oOutStack.Stack[1].Value, oOutStack.Stack[0].Value);
      oOutStack.PopVar;
      oOutStack.PopVar;
    end;
    // А затем кладем на место вынутых операторов только что созданную операцию
    oOutStack.PushVar(oLeft);
    // и удаляем лексему операции из стека
    FTokenStack.Pop;
  end;

  // После этого в стекен е должно оставаться ни одного оператора
  Result := oOutStack.PopVar;
  oOutStack.Free;
end;
(**
 * Метод чтения заголовка цикла for.
 * Вход в метод эквивалентен правилу #KwExprFOR#
 *
 * Параметры:
 *   oFOR - ссылка на оператор цикла for, для которого будет считан
 *
 *)
Procedure TCodeProcessor.ReadHeaderFOR(oFOR: TExpressionFOR);
var
  // Ссылка на первое выражение оператора - выражение инициализации
  oInitSection: TConstant;
  // Ссылка на второе выражение - выражение условия
  oStepCond: TConstant;
  // Сслыка на третье выражение оператора - шаг счетчика
  oStepAction: TConstant;
  // Бегунок для поиска конца заголовка оператора for
  oWalker: TToken;
  // счетчик скобок, для проверки корректности расстановки скобок
  iBrekets: integer;
begin
  // Сперва обязательно должна быть открывающая скобка, она идет следом за словом for
  if FCode.Current.Value <> '(' then SetError(esUnexpSymbol);
  FCode.Next;

  // Первое выражение можно считать как обычно, оно может быть точно таким же, как и простое выражение
  oInitSection := ParseExpression;
  if FCode.Current.Value <> ';' then SetError(esUnexpSymbol);
  FCode.Next;

  // Второе выражение точно так же можно считать как обычное, оно тоже может быть как и простое выражение
  oStepCond := ParseExpression;
  if FCode.Current.Value <> ';' then SetError(esUnexpSymbol);
  FCode.Next;

  // А вот третье выражение огрничивается закрывающей скобкой, которую нужно отловить
  // Поэтому сперва находим нужную закрывающую скобочку, их может быть и несколько на пути
  oWalker := FCode.Current;
  iBrekets := 1;
  while (oWalker <> nil) and (iBrekets > 0) do begin
    case oWalker.Value[1] of
      '(': inc(iBrekets);
      ')': dec(iBrekets);
    end;
    if iBrekets > 0 then oWalker := oWalker.Next;
  end;
  // Если нужную скобочку не удалось найти, значит в описании оператора ошибка
  if oWalker = nil then SetError(esUnclosedExpression);

  // Теперь можно разобрать и третье выражение из заголовка
  oStepAction := ParseExpressionSpec(oWalker);
  if FCode.Current.Value <> ')' then SetError(esUnexpSymbol);
  FCode.Next;

  // А под конец осталось произвести инициализацию оператора for с разобранными выражениями
  oFOR.Init(oInitSection, oStepCond, oStepAction);
end;
(**
 * Метод чтения параметров вызова функции.
 *
 * Вход в метод эквивалентен правилу #CallFunc#
 *
 *)
Procedure TCodeProcessor.ReadHeaderCallFunc(oCallFunc: TFunctionCall);
var
  // бегунок для определения конца текущего параметра
  oWalker: TToken;
  // счетчик скобочек, служит для проверки правильности расстановки скобок
  iBrekets: integer;
begin
  // Сперва должна быть открывающая скобочка
  if FCode.Current.Value <> '(' then SetError(esUnexpSymbol);
  FCode.Next;

  iBrekets := 1;
  // параметры записаны через запятую, последний завершается скобочкой
  while (iBrekets > 0) and (not FCode.EOF) do begin
    oWalker := FCode.Current;
    // Ищем запятую или скобочку и устанавливаем этот символ как конец параметра
    while oWalker <> nil do begin
      case oWalker.Value[1] of
        '(': inc(iBrekets);
        ')': dec(iBrekets);
        ',': break;
      end;
      if iBrekets < 1 then break;
      oWalker := oWalker.Next;
    end;
    // ограничение нашлось сразу же, значит параметры явно кончились
    if oWalker = FCode.Current then break;
    // Делаем разбор выражения параметра и добавляем его в список вызова функции
    oCallFunc.Params.Add(ParseExpressionSpec(oWalker));
    // Немного дополнительных проверок, для уверенности, что разбор завершился где надо
    if FCode.Current.Value <> oWalker.Value then SetError(esUnclosedExpression);
    if FCode.Current.Value = ',' then FCode.Next;
  end;
  // Под конец была пройдена последняя скобочка, закрывающая вызов функции, счетчик обязан быть в нуле
  if iBrekets <> 0 then SetError(esUnclosedExpression);

  // Если разбора был остановлен не в момент встречи последней закрывающей скобочки, это ошибка
  if FCode.Current.Value <> ')' then SetError(esUnexpSymbol);
end;
(**
 * Метод чтения параметро вызова echo.
 * Вход в метод эквивалентен правилу #KwExprECHO#
 *
 *)
Procedure TCodeProcessor.ReadHeaderEcho(oEcho: TExpressionECHO);
var
  // бегунок для определения конца текущего параметра
  oWalker: TToken;
  // счетчик скобочек, служит для проверки правильности расстановки скобок
  iBrekets: integer;
  // помошник по разным нуждам, для хранения ссылок на операторы
  oHelper: TConstant;
begin
  // Сперва должна быть открывающая скобочка
  if FCode.Current.Value <> '(' then SetError(esUnexpSymbol);
  FCode.Next;

  iBrekets := 1;
  // параметры записаны через запятую, последний завершается скобочкой
  while (iBrekets > 0) and (not FCode.EOF) do begin
    oWalker := FCode.Current;
    // Ищем запятую или скобочку и устанавливаем этот символ как конец параметра
    while oWalker <> nil do begin
      if oWalker.TokenType <> ttString then begin
        case oWalker.Value[1] of
          '(': inc(iBrekets);
          ')': dec(iBrekets);
          ',': break;
        end;
      end;
      if iBrekets < 1 then break;
      oWalker := oWalker.Next;
    end;
    // ограничение нашлось сразу же, значит параметры явно кончились
    if oWalker = FCode.Current then break;

    // В echo есть возможность использовать строки как параметры
    if FCode.Current.TokenType = ttString then begin
      // Вот именно тут и происходит генерация кода для строковых констант
      oHelper := TSTRConstant.Create(FScriptStack[0], FCode.Current);
      TSTRConstant(oHelper).Init(FCode.Current.Value);
      oHelper.Flags := [ofTraceOff,ofNotActive];
      oEcho.Params.Add(oHelper);
      FCode.Next;
    end else begin
      // Делаем разбор выражения параметра и добавляем его в список вызова функции
      oEcho.Params.Add(ParseExpressionSpec(oWalker));
    end;
    // Немного дополнительных проверок, для уверенности, что разбор завершился где надо
    if FCode.Current.Value <> oWalker.Value then SetError(esUnclosedExpression);
    if FCode.Current.Value = ',' then FCode.Next;
  end;
  // Под конец была пройдена последняя скобочка, закрывающая вызов функции, счетчик обязан быть в нуле
  if iBrekets <> 0 then SetError(esUnclosedExpression);

  // Если разбора был остановлен не в момент встречи последней закрывающей скобочки, это ошибка
  if FCode.Current.Value <> ')' then SetError(esUnexpSymbol);
  FCode.Next;
end;

(**
 * Метод разбора конструкций ключевых слов.
 *
 * Вход в метод эквивалентен правилу #Keyword#
 *
 *)
Procedure TCodeProcessor.ParseBaseKeyword;
var
  // флажок, сигнализирующий о удачном разборе выражения.
  bKeyParsed: boolean;
  // Ссылка на генерируемый оператор
  oOperator: TBaseOperator;
  // Помошник для хранения разных ссылок
  oHelper: TConstant;

begin
  // Сначала говорим, что разбор не завершен
  bKeyParsed := false;

  // 'const' - приставка к типу данных
  if (not bKeyParsed) and (FCode.Current.Value = 'const') then begin
    // Запоминаем лексему и просто идем дальше
    FTokenStack.Push(FCode.Current);
    FCode.Next;
    // Если следующая за словом лексема не является типом, значит ошибка
    if FCode.Current.TokenType <> ttType then SetError(esUnexpSymbol);
    // Разбор завершен
    bKeyParsed := true;
  end;

  // Разбор выражения return
  if (not bKeyParsed) and (Fcode.Current.Value = 'return') then begin
    // оператор может вызываться только в подпрограмме функции, иначе ошибка
    if FFuncStack[0] = nil then SetError(esUnexpSymbol);

    // Запоминаем
    FTokenStack.Push(Fcode.Current);
    FCode.Next;

    oOperator := TExpressionRET.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
    // Читаем выражение, значение которого нужно вернуть
    oHelper := ParseExpression;
    // просто лишний раз проверяем, все ли в разборе в порядке
    if FCode.Current.Value <> ';' then SetError(esUnexpSymbol);
    // Инициализируем оператор
    TExpressionRET(oOperator).Init(FFuncStack[0].Value, oHelper);

    // Разбор завершен, лишнее выталкиваем
    bKeyParsed := true;
    FTokenStack.Pop;
    FCode.Next;
  end;

  // Разбор выражения IF
  if (not bKeyParsed) and (Fcode.Current.Value = 'if') then begin
    // Запоминаем лексему if
    FTokenStack.Push(Fcode.Current);
    FCode.Next;

    // Проверяем наличие открывающей скобочки для правильности
    if FCode.Current.Value <> '(' then SetError(esUnexpSymbol);
    // Делаем разбор условия оператора
    oHelper := ParseExpression;
    // Проверяем, что разбор условия был завершен на нужном месте
    if FCode.Current.Value <> '{' then SetError(esUnexpSymbol);

    // Теперь можно генерировать оператор
    oOperator := TExpressionIF.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
    TExpressionIF(oOperator).Init(oHelper);
    // Сразу же сигнализируем, что теперь будем разбирать подпрограмму оператора
    PushScript(TExpressionIF(oOperator).Action);

    // Разбор завершен, подчищаем стек лексем, все в порядке, можно выходить
    bKeyParsed := true;
    FTokenStack.Pop;
    Fcode.Next;
  end;

  // Разбор выражения else
  if (not bKeyParsed) and (Fcode.Current.Value = 'else') then begin
    FCode.Next;
    // после else тоже должна описываться подпрограмма
    if FCode.Current.Value <> '{' then SetError(esUnexpSymbol);
    // Последним разобранным в скрипте оператором обязан быть if
    oOperator := FScriptStack.Script[0].Operators[FScriptStack.Script[0].Count - 1];
    if (oOperator = nil) or (oOperator.Name.Value <> 'if') or (ofElseAssigned in oOperator.Flags) then SetError(esUnexpSymbol);

    // Сигнализируем о начале разбора подпрограммы else и устанавливаем в if флаг наличия else секции
    PushScript(TExpressionIF(oOperator).AlterAction);
    oOperator.Flags := oOperator.Flags + [ofElseAssigned];

    // Разбор завершен, все в опрядке
    bKeyParsed := true;
    FCode.Next;
  end;

  // Разбор выражения for
  if (not bKeyParsed) and (Fcode.Current.Value = 'for') then begin
    FTokenStack.Push(Fcode.Current);
    FCode.Next;

    if FCode.Current.Value <> '(' then SetError(esUnexpSymbol);
    // Генерируем оператор цикла
    oOperator := TExpressionFOR.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
    // Счиываем параметры цикла...
    ReadHeaderFOR(TExpressionFOR(oOperator));

    if FCode.Current.Value <> '{' then SetError(esUnexpSymbol);
    // Сигнализируем о начале разбора подпрограммы for
    PushScript(TExpressionFOR(oOperator).Action);

    bKeyParsed := true;
    FTokenStack.Pop;
    FCode.Next;
  end;

  // Разбираем цикл while, или продолжаем разбирать выражение do-while
  if (not bKeyParsed) and (Fcode.Current.Value = 'while') then begin
    FTokenStack.Push(Fcode.Current);
    FCode.Next;

    if FCode.Current.Value <> '(' then SetError(esUnexpSymbol);
    // разбираем условие цикла
    oHelper := ParseExpression;
    // Находим в текущем скрипте последний оператор, это может быть do
    oOperator := FScriptStack.Script[0].Operators[FScriptStack.Script[0].Count - 1];
    // Если такой оператор все таки есть, если это do и если он еще не был определен, то...
    if (oOperator <> nil) and ((oOperator.Name.Value = 'do') and not(ofDoAssigned in oOperator.Flags)) then begin
      // инициализируем оператор разобранным условием
      TExpressionDO(oOperator).Init(oHelper);
      oOperator.Flags := oOperator.Flags + [ofDoAssigned];
      if FCode.Current.Value <> ';' then SetError(esUnexpSymbol);
    end else begin
      // А иначе это цикл while и надо его разобрать по его правилам
      if FCode.Current.Value <> '{' then SetError(esUnexpSymbol);

      // Генерируем оператор и определяем его с условием
      oOperator := TExpressionWHILE.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
      TExpressionWHILE(oOperator).Init(oHelper);
      // Сигнализируем о начале разбора подпрограммы цикла while
      PushScript(TExpressionWHILE(oOperator).Action);
    end;

    bKeyParsed := true;
    FTokenStack.Pop;
    Fcode.Next;
  end;

  // Разбор выражения do-, да, это еще не do-while, это пока просто do-
  if (not bKeyParsed) and (Fcode.Current.Value = 'do') then begin
    FTokenStack.Push(Fcode.Current);
    FCode.Next;

    // Наличие подпрограммы обязательно
    if FCode.Current.Value <> '{' then SetError(esUnexpSymbol);

    // Создаем оператор do и сигнализируем о начале разбора его подпрограммы
    oOperator := TExpressionDO.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
    PushScript(TExpressionIF(oOperator).Action);

    bKeyParsed := true;
    FTokenStack.Pop;
    Fcode.Next;
  end;

  // Разбор выражения echo
  if (not bKeyParsed) and (Fcode.Current.Value = 'echo') then begin
    FTokenStack.Push(Fcode.Current);
    FCode.Next;

    // echo всегда вызывается как функция и всегда только с параметрами, скобочка обязательна
    if FCode.Current.Value <> '(' then SetError(esUnexpSymbol);
    // Генерируем код операора и считываем его параметры, а затем инициализируем
    oOperator := TExpressionECHO.Create(FScriptStack.Script[0], FTokenStack.Token[0]);
    ReadHeaderEcho(TExpressionECHO(oOperator));
    TExpressionECHO(oOperator).Init;
    if FCode.Current.Value <> ';' then SetError(esUnexpSymbol);

    bKeyParsed := true;
    FTokenStack.Pop;
    Fcode.Next;
  end;

  if (not bKeyParsed) then SetError(esUnexpSymbol);
end;

(**
 * Метод разбора сложных математических выражений в коде.
 *
 * Метод является лишь шиной для ParseExpression из соображений безопасности кода
 *
 *)
Procedure TCodeProcessor.ParseBaseOperation;
begin
  // Делаем разббор выражения до самой точки с запятой, а затем снимаем его флаг исполняемости
  with ParseExpression do begin
    // теперь корень полученного дерева операторов станет исполняемым в методе TScript.Run
    Flags := Flags - [ofTraceOff];
  end;
  if FCode.Current.Value <> ';' then SetError(esUnexpSymbol);
  FCode.Next;
end;

(**
 * Метод разбора изолированных символов.
 * В целях оптимизации операций метод реализует поведение согласно двум правилам.
 *
 * Вход в метод эквивалентен правилам #SubBlock# и #SubBlockEnd#
 *
 *)
Procedure TCodeProcessor.ParseBaseSymbol;
var
  // Используется в различных целях для хранения ссылки на оператор
  oOperator: TBaseOperator;
  // Используется для хранения только что вытолкнутого скрипта
  oScript: TScript;

begin
  // проверяем, каков первый символ лексемы
  case FCode.Current.Value[1] of
    '{': begin
      // Выходит, был определен оператор подпрограммы, создаем его...
      oOperator := TSubScript.Create(FScriptStack.Script[0], FCode.Current);

      // Сигнализируем о начале разбора подпрограммы этого оператора
      PushScript(TSubScript(oOperator).Action);

      TSubScript(oOperator).Init;
    end;

    '}': begin
      // Тут производится завершение разбора любой подпрограммы

      // Если в стеке скриптов нет ни одного скрипта помимо основной программы, значит ошибка
      if FScriptStack.Count < 2 then SetError(esUnexpSymbol);

      // Сигнализируем о завершении разбора текущей подпрограммы
      oScript := PopScript;

      // Если Только что вытолкнутая подпрограмма является подпрограммой функции,
      // то надо и функцию вытолкнуть из стека вызовов, т.к. произошел выход за ее пределы
      if FFuncStack[0] <> nil then begin
        if FFuncStack[0].Value.Action = oScript then FFuncStack.PopFunc;
      end;

      // Дополнительные проверки составных операторов
      oOperator := FScriptStack[0][FScriptStack[0].Count - 1];
      if (oOperator <> nil) and (FCode.Current.Next <> nil) then begin
        // Оператор do обязательно должен содержать заголовой while после своей подпрограммы
        if (oOperator.Name.Value = 'do') and (FCode.Current.Next.Value <> 'while') then SetError(esUnexpSymbol);
      end;

      // Подпрограмма может завершиться просто символом "}", а может и - "};"
      if FCode.Current.Next.Value = ';' then FCode.Next;
    end;

    // А в люых других случаях сигнализируем об ошибке
    else SetError(esUnexpSymbol);
  end;
  
  FCode.Next;
end;
//--------------------------------------------------------------------------------------------------
//--- TScriptStack class body ----------------------------------------------------------------------
(**
 * Конструктор стека.
 * Дополнительно создает хранилище скриптов.
 *
 *)
Constructor TScriptStack.Create;
begin
  FStack := TList.Create;
end;

(**
 * Деструктор стека.
 * Необходим для очистки хранилища от ссылок и освобождения занимаемой им памяти.
 *
 *)
Destructor TScriptStack.Destroy;
begin
  // Очищаем стек и удалем его из памяти
  FStack.Clear;
  FStack.Free;
  inherited Destroy;
end;

(**
 * Механизм стека, позволяющий вставить скрипт в стек.
 *
 * Параметры:
 *   oScript - ссылка на скрипт, который необходимо добавить в стек.
 *
 *)
Procedure TScriptStack.Push(oScript: TScript);
begin
  FStack.Insert(0, oScript);
end;

(**
 * Механизм стека, позволяющий вытолкнуть скрипт из стека.
 *
 * Возвращает ссылку на вытолкнутый скрипт, или nil, если стек итак был пустым.
 *
 *)
Function TScriptStack.Pop: TScript;
begin
  if FStack.Count > 0 then begin
    Result := TScript(FStack.Items[0]);
    FStack.Delete(0);
  end else Result := nil;
end;

(**
 * Возвращает количество скриптов в стеке.
 *
 *)
Function TScriptStack.GetCount: integer;
begin
  Result := FStack.Count;
end;

(**
 * Возвращает ссылку на скрипт по его условному индексу.
 *
 * Параметры:
 *   iIndex - Условный индекс скрипта, ссылку на который необходимо получить.
 *
 * Возвращает объект TScript, если все хорошо, или nil, если по индексу скрипт не найден. 
 *
 *)
Function TScriptStack.GetScript(iIndex: integer): TScript;
begin
  if (FStack.Count > iIndex) and (iIndex >= 0) then
    Result := TScript(FStack.Items[iIndex])
  else
    Result := nil;
end;
//--------------------------------------------------------------------------------------------------
//--- TTokenStack class body ----------------------------------------------------------------------
(**
 * Конструктор стека.
 * Дополнительно создает объект хранилища лексем.
 *
 *)
Constructor TTokenStack.Create;
begin
  FStack := TList.Create;
end;

(**
 * Деструктор стека.
 * Необходим для очистки хранилища лексем и освобождения занимаемой им памяти.
 *
 *)
Destructor TTokenStack.Destroy;
begin
  FStack.Clear;
  FStack.Free;
  inherited Destroy;
end;

(**
 * Механизм стека, позволяющий вставить лексему в стек.
 *
 * Параметры:
 *   oToken - ссылка на лексему, которую необходимо добавить в стек.
 *
 *)
Procedure TTokenStack.Push(oToken: TToken);
begin
  FStack.Insert(0, oToken);
end;

(**
 * Механизм стека, позволяющий вытолкнуть лексему из стека.
 *
 * Возвращает ссылку на вытолкнутую лексему, или nil, если стек итак был пустым.
 *
 *)
Function TTokenStack.Pop: TToken;
begin
  if FStack.Count > 0 then begin
    Result := TToken(FStack.Items[0]);
    FStack.Delete(0);
  end else Result := nil;
end;

(**
 * Возвращает количество скриптов в стеке.
 *
 *)
Function TTokenStack.GetCount: integer;
begin
  Result := FStack.Count;
end;

(**
 * Возвращает ссылку на лексему по ее условному интексу.
 *
 * Параметры:
 *   iIndex - Условный индекс, относительно которого необходимо получить лексему.
 *
 * Возвращает ссылку на лексему, если все хорошо, или nil, если по индексу не нашлось лексемы
 *
 *)
Function TTokenStack.GetToken(iIndex: integer): TToken;
begin
  if (FStack.Count > iIndex) and (iIndex >= 0) then
    Result := TToken(FStack.Items[iIndex])
  else
    Result := nil;
end;
//--------------------------------------------------------------------------------------------------
//--- TProcessorException class body ---------------------------------------------------------------
(**
 * Конструктор исключения.
 *
 * Параметры:
 *   eCode - код возникшей ошибки.
 *
 *)
Constructor TProcessorException.Create(eCode: TParserErrorState);
begin
  inherited Create('');
  FCode := eCode;
end;
//--------------------------------------------------------------------------------------------------
//--- TVarStack class body -------------------------------------------------------------------------
(**
 * Конструктор стека.
 * Дополнительно, создает объект хранилища ссылок.
 *
 *)
constructor TVarStack.Create;
begin
  FStack := TList.Create;
  FMainScript := nil;
  FLocalScript := nil;
end;

(**
 * Деструктор стека.
 * Очищает стек и удаляет объект хранилища.
 *
 *)
Destructor TVarStack.Destroy; 
begin
  Clear;
  FStack.Free;
  inherited Destroy;
end;

(**
 * Производит вставку элемента в стек.
 * Вызывается автоматически в конструкторе класса TVarStackItem.
 *
 * Параметры:
 *   oVar - ссылка на элемент, который надо вставить.
 *
 *)
Procedure TVarStack.AddVar(oVar: TVarStackItem); 
begin
  FStack.Insert(0, oVar);
end;

(**
 * Производит выталкивание элемента из стека.
 * Вызывается автоматически в деструкторе класса TVarStackItem.
 *
 * Параметры:
 *   oVar - ссылка на элемент, который надо вытолкнуть.
 *
 *)
Procedure TVarStack.RemVar(oVar: TVarStackItem); 
begin
  FStack.Remove(oVar);
end;

(**
 * Возвращает ссылку на элемент стека по его условному индексу.
 *
 * Параметры:
 *   iIndex - условный индекс, по которому нужно получит переменную или константу.
 *
 * Возвращает ссылку на элемент, если все в порядке, или nil, если по индексу не
 * нашлось элемента.
 *
 *)
Function TVarStack.GetVar(iIndex: integer): TVarStackItem;
begin
  if (iIndex >= 0) and (FStack.Count > iIndex) then Result := TVarStackItem(FStack.Items[iIndex])
  else Result := nil;
end;

(**
 * Возвращает количество ссылок в хранилище на данное время.
 *
 *)
FUnction TVarStack.GetCount: integer;
begin
  Result := FStack.Count;
end;

(**
 * Полностью очищает стек.
 *
 *)
Procedure TVarStack.Clear;
begin
  while FStack.Count > 0 do TVarStackItem(FStack.Items[0]).Free;
end;

(**
 * Интерфейс входа в скрипт.
 * Устанавливает новый локальный скрипт.
 *
 * Параметры:
 *   oScript - скрипт, который будет локальным
 *
 *)
Procedure TVarStack.EnterScript(oScript: TScript);
begin
  FLocalScript := oScript;
end;

(**
 * Интерфейс выхода из скрипта.
 * Выталкивает все ссылки для локального скрипта и изменяет ссылку на сам локальный скрипт.
 *
 * Параметры:
 *   oScript - Ссылка на скрипт, относительно которого выполняется метод выхода.
 *             По умолчанию это текущий локальный скрипт.
 *
 *)
Procedure TVarStack.LeaveScript(oScript: TScript);
begin
  if oScript = nil then oScript := FLocalScript;
  while (FStack.Count > 0) and (TVarStackItem(FStack.Items[0]).Script = oScript) do TVarStackItem(FStack.Items[0]).Free;
  if FStack.Count > 0 then FLocalScript := TVarStackItem(FStack.Items[0]).Script
  else FLocalScript := FMainScript;
end;

(**
 * Метод вставки элемента.
 * Производит вставку переменной для текущего локального скрипта.
 *
 * Параметру:
 *   oVar - ссылка на переменную или константу, которую нужно зарегистрировать.
 *
 *)
Procedure TVarStack.PushVar(oVar: TConstant);
begin
  TVarStackItem.Create(Self, oVar);
end;

(**
 * Метод выталкивания элемента.
 * Производит выталкивание ссылки из стека.
 *
 *)
Function TVarStack.PopVar: TConstant;
begin
  Result := nil;
  if FStack.Count < 1 then exit;
  Result := TVarStackItem(FStack.Items[0]).Value;
  TVarStackItem(FStack.Items[0]).Free;
end;

(**
 * Поиск переменной или константы по ее имени.
 *
 * Параметры:
 *   oName - лексема, значение которой будет использоваться для поиска ссылки.
 *
 * Возвращает ссылку на элемент стека, если было найдено совпадение, или nil, если нет.
 *
 *)
Function TVarStack.FindVar(oName: TToken): TVarStackItem;
var
  iWalk: integer;
begin
  iWalk := 0;
  Result := nil;
  while FStack.Count > iWalk do begin
    if TVarStackItem(FStack.Items[iWalk]).Value.Name.Value = oName.Value then begin
      Result := TVarStackItem(FStack.Items[iWalk]);
      break;
    end;
    inc(iWalk);
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TVarStackItem class body ---------------------------------------------------------------------
(**
 * Конструктор элмента.
 * Самостоятельно производит вставку своей ссылки в родительский стек.
 *
 * Параметры:
 *   oParent - ссылка на стек, в котором заводится данный элемент
 *   oValue  - ссылка на константу или переменную, для которой заводится элемент.
 *
 *)
constructor TVarStackItem.Create(oParent: TVarStack; oValue: TConstant);
begin
  FParent := oParent;
  FParent.AddVar(Self);
  FValue := oValue;
  FScript := FParent.CurrentScript;
end;

(**
 * Деструктор элемента.
 * Самостоятельно производит удаление своей ссылки из родительского стека.
 *
 *)
destructor TVarStackItem.Destroy;
begin
  FParent.RemVar(Self);
  inherited Destroy;
end;
//--------------------------------------------------------------------------------------------------
//--- TFuncStack class body ------------------------------------------------------------------------
(**
 * Конструктор стека.
 * Дополнительно, создает объект хранилища ссылок.
 *
 *)
Constructor TFuncStack.Create;
begin
  FStack := TList.Create;
  FMainScript := nil;
  FLocalScript := nil;
end;

(**
 * Деструктор стека.
 * Очищает стек и удаляет объект хранилища.
 *
 *)
Destructor TFuncStack.Destroy;
begin
  Clear;
  FStack.Free;
  inherited Destroy;
end;

(**
 * Производит вставку элемента в стек.
 * Вызывается автоматически в конструкторе класса TFuncStackItem.
 *
 * Параметры:
 *   oFunc - ссылка на элемент, который надо вставить.
 *
 *)
Procedure TFuncStack.AddFunc(oFunc: TFuncStackItem);
begin
  FStack.Insert(0, oFunc);
end;

(**
 * Производит выталкивание элемента из стека.
 * Вызывается автоматически в деструкторе класса TFuncStackItem.
 *
 * Параметры:
 *   oFunc - ссылка на элемент, который надо вытолкнуть.
 *
 *)
Procedure TFuncStack.RemFunc(oFunc: TFuncStackItem);
begin
  FStack.Remove(oFunc);
end;

(**
 * Возвращает ссылку на элемент стека по его условному индексу.
 *
 * Параметры:
 *   iIndex - условный индекс, по которому нужно получит функцию.
 *
 * Возвращает ссылку на элемент, если все в порядке, или nil, если по индексу не
 * нашлось элемента.
 *
 *)
Function TFuncStack.GetFunc(iIndex: integer): TFuncStackItem;
begin
  if (iIndex >= 0) and (FStack.Count > iIndex) then Result := TFuncStackItem(FStack.Items[iIndex])
  else Result := nil;
end;

(**
 * Возвращает количество ссылок в хранилище на данное время.
 *
 *)
FUnction TFuncStack.GetCount: integer;
begin
  Result := FStack.Count;
end;

(**
 * Полностью очищает стек.
 *
 *)
Procedure TFuncStack.Clear;
begin
  while FStack.Count > 0 do TFuncStackItem(FStack.Items[0]).Free;
end;

(**
 * Интерфейс входа в скрипт.
 * Устанавливает новый локальный скрипт.
 *
 * Параметры:
 *   oScript - скрипт, который будет локальным
 *
 *)
Procedure TFuncStack.EnterScript(oScript: TScript);
begin
  FLocalScript := oScript;
end;

(**
 * Интерфейс выхода из скрипта.
 * Выталкивает все ссылки для локального скрипта и изменяет ссылку на сам локальный скрипт.
 *
 * Параметры:
 *   oScript - Ссылка на скрипт, относительно которого выполняется метод выхода.
 *             По умолчанию это текущий локальный скрипт.
 *
 *)
Procedure TFuncStack.LeaveScript(oScript: TScript);
begin
  if oScript = nil then oScript := FLocalScript;
  while (FStack.Count > 0) and (TFuncStackItem(FStack.Items[0]).Script = oScript) do TFuncStackItem(FStack.Items[0]).Free;
  if FStack.Count > 0 then FLocalScript := TFuncStackItem(FStack.Items[0]).Script
  else FLocalScript := FMainScript;
end;

(**
 * Метод вставки элемента.
 * Производит вставку переменной для текущего локального скрипта.
 *
 * Параметру:
 *   oFunc - ссылка на функцию, которую нужно зарегистрировать.
 *
 *)
Procedure TFuncStack.PushFunc(oFunc: TFunction);
begin
  TFuncStackItem.Create(Self, oFunc);
end;

(**
 * Метод выталкивания элемента.
 * Производит выталкивание ссылки из стека.
 *
 *)
Function TFuncStack.PopFunc: TFunction;
begin
  Result := nil;
  if FStack.Count < 1 then exit;
  Result := TFuncStackItem(FStack.Items[0]).Value;
  TFuncStackItem(FStack.Items[0]).Free;
end;

(**
 * Поиск функции по ее имени.
 *
 * Параметры:
 *   oName - лексема, значение которой будет использоваться для поиска ссылки.
 *
 * Возвращает ссылку на элемент стека, если было найдено совпадение, или nil, если нет.
 *
 *)
Function TFuncStack.FindFunc(oName: TToken): TFuncStackItem;
var
  iWalk: integer;
begin
  iWalk := 0;
  Result := nil;
  while FStack.Count > iWalk do begin
    if TFuncStackItem(FStack.Items[iWalk]).Value.Name.Value = oName.Value then begin
      Result := TFuncStackItem(FStack.Items[iWalk]);
      break;
    end;
    inc(iWalk);
  end;
end;
//--------------------------------------------------------------------------------------------------
//--- TFuncStackItem class body --------------------------------------------------------------------
(**
 * Конструктор элмента.
 * Самостоятельно производит вставку своей ссылки в родительский стек.
 *
 * Параметры:
 *   oParent - ссылка на стек, в котором заводится данный элемент
 *   oValue  - ссылка на функцию, для которой заводится элемент.
 *
 *)
Constructor TFuncStackItem.Create(oParent: TFuncStack; oValue: TFunction);
begin
  FParent := oParent;
  FParent.AddFunc(Self);
  FValue := oValue;
  FScript := FParent.CurrentScript;
end;

(**
 * Деструктор элемента.
 * Самостоятельно производит удаление своей ссылки из родительского стека.
 *
 *)
destructor TFuncStackItem.Destroy;
begin
  FParent.RemFunc(Self);
  inherited Destroy;
end;
//--------------------------------------------------------------------------------------------------
end.
